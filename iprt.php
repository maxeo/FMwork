<?php

// --------------------------------------------------------------------------------

// PhpConcept Library - Zip Module 2.8.2

// --------------------------------------------------------------------------------

// License GNU/LGPL - Vincent Blavet - August 2009

// http://www.phpconcept.net

// --------------------------------------------------------------------------------

//

// Presentation :

//   PclZip is a PHP library that manage ZIP archives.

//   So far tests show that archives generated by PclZip are readable by

//   WinZip application and other tools.

//

// Description :

//   See readme.txt and http://www.phpconcept.net

//

// Warning :

//   This library and the associated files are non commercial, non professional

//   work.

//   It should not have unexpected results. However if any damage is caused by

//   this software the author can not be responsible.

//   The use of this software is at the risk of the user.

//

// --------------------------------------------------------------------------------

// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $

// --------------------------------------------------------------------------------

// ----- Constants

if (!defined('PCLZIP_READ_BLOCK_SIZE')) {

    define('PCLZIP_READ_BLOCK_SIZE', 2048);

}



// ----- File list separator

// In version 1.x of PclZip, the separator for file list is a space

// (which is not a very smart choice, specifically for windows paths !).

// A better separator should be a comma (,). This constant gives you the

// abilty to change that.

// However notice that changing this value, may have impact on existing

// scripts, using space separated filenames.

// Recommanded values for compatibility with older versions :

//define( 'PCLZIP_SEPARATOR', ' ' );

// Recommanded values for smart separation of filenames.

if (!defined('PCLZIP_SEPARATOR')) {

    define('PCLZIP_SEPARATOR', ',');

}



// ----- Error configuration

// 0 : PclZip Class integrated error handling

// 1 : PclError external library error handling. By enabling this

//     you must ensure that you have included PclError library.

// [2,...] : reserved for futur use

if (!defined('PCLZIP_ERROR_EXTERNAL')) {

    define('PCLZIP_ERROR_EXTERNAL', 0);

}



// ----- Optional static temporary directory

//       By default temporary files are generated in the script current

//       path.

//       If defined :

//       - MUST BE terminated by a '/'.

//       - MUST be a valid, already created directory

//       Samples :

// define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );

// define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );

if (!defined('PCLZIP_TEMPORARY_DIR')) {

    define('PCLZIP_TEMPORARY_DIR', '');

}



// ----- Optional threshold ratio for use of temporary files

//       Pclzip sense the size of the file to add/extract and decide to

//       use or not temporary file. The algorythm is looking for 

//       memory_limit of PHP and apply a ratio.

//       threshold = memory_limit * ratio.

//       Recommended values are under 0.5. Default 0.47.

//       Samples :

// define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );

if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {

    define('PCLZIP_TEMPORARY_FILE_RATIO', 0.47);

}



// --------------------------------------------------------------------------------

// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****

// --------------------------------------------------------------------------------

// ----- Global variables

$g_pclzip_version = "2.8.2";



// ----- Error codes

//   -1 : Unable to open file in binary write mode

//   -2 : Unable to open file in binary read mode

//   -3 : Invalid parameters

//   -4 : File does not exist

//   -5 : Filename is too long (max. 255)

//   -6 : Not a valid zip file

//   -7 : Invalid extracted file size

//   -8 : Unable to create directory

//   -9 : Invalid archive extension

//  -10 : Invalid archive format

//  -11 : Unable to delete file (unlink)

//  -12 : Unable to rename file (rename)

//  -13 : Invalid header checksum

//  -14 : Invalid archive size

define('PCLZIP_ERR_USER_ABORTED', 2);

define('PCLZIP_ERR_NO_ERROR', 0);

define('PCLZIP_ERR_WRITE_OPEN_FAIL', -1);

define('PCLZIP_ERR_READ_OPEN_FAIL', -2);

define('PCLZIP_ERR_INVALID_PARAMETER', -3);

define('PCLZIP_ERR_MISSING_FILE', -4);

define('PCLZIP_ERR_FILENAME_TOO_LONG', -5);

define('PCLZIP_ERR_INVALID_ZIP', -6);

define('PCLZIP_ERR_BAD_EXTRACTED_FILE', -7);

define('PCLZIP_ERR_DIR_CREATE_FAIL', -8);

define('PCLZIP_ERR_BAD_EXTENSION', -9);

define('PCLZIP_ERR_BAD_FORMAT', -10);

define('PCLZIP_ERR_DELETE_FILE_FAIL', -11);

define('PCLZIP_ERR_RENAME_FILE_FAIL', -12);

define('PCLZIP_ERR_BAD_CHECKSUM', -13);

define('PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14);

define('PCLZIP_ERR_MISSING_OPTION_VALUE', -15);

define('PCLZIP_ERR_INVALID_OPTION_VALUE', -16);

define('PCLZIP_ERR_ALREADY_A_DIRECTORY', -17);

define('PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18);

define('PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19);

define('PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20);

define('PCLZIP_ERR_DIRECTORY_RESTRICTION', -21);



// ----- Options values

define('PCLZIP_OPT_PATH', 77001);

define('PCLZIP_OPT_ADD_PATH', 77002);

define('PCLZIP_OPT_REMOVE_PATH', 77003);

define('PCLZIP_OPT_REMOVE_ALL_PATH', 77004);

define('PCLZIP_OPT_SET_CHMOD', 77005);

define('PCLZIP_OPT_EXTRACT_AS_STRING', 77006);

define('PCLZIP_OPT_NO_COMPRESSION', 77007);

define('PCLZIP_OPT_BY_NAME', 77008);

define('PCLZIP_OPT_BY_INDEX', 77009);

define('PCLZIP_OPT_BY_EREG', 77010);

define('PCLZIP_OPT_BY_PREG', 77011);

define('PCLZIP_OPT_COMMENT', 77012);

define('PCLZIP_OPT_ADD_COMMENT', 77013);

define('PCLZIP_OPT_PREPEND_COMMENT', 77014);

define('PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015);

define('PCLZIP_OPT_REPLACE_NEWER', 77016);

define('PCLZIP_OPT_STOP_ON_ERROR', 77017);

// Having big trouble with crypt. Need to multiply 2 long int

// which is not correctly supported by PHP ...

//define( 'PCLZIP_OPT_CRYPT', 77018 );

define('PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019);

define('PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020);

define('PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020); // alias

define('PCLZIP_OPT_TEMP_FILE_ON', 77021);

define('PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021); // alias

define('PCLZIP_OPT_TEMP_FILE_OFF', 77022);

define('PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022); // alias

// ----- File description attributes

define('PCLZIP_ATT_FILE_NAME', 79001);

define('PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002);

define('PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003);

define('PCLZIP_ATT_FILE_MTIME', 79004);

define('PCLZIP_ATT_FILE_CONTENT', 79005);

define('PCLZIP_ATT_FILE_COMMENT', 79006);



// ----- Call backs values

define('PCLZIP_CB_PRE_EXTRACT', 78001);

define('PCLZIP_CB_POST_EXTRACT', 78002);

define('PCLZIP_CB_PRE_ADD', 78003);

define('PCLZIP_CB_POST_ADD', 78004);

/* For futur use

  define( 'PCLZIP_CB_PRE_LIST', 78005 );

  define( 'PCLZIP_CB_POST_LIST', 78006 );

  define( 'PCLZIP_CB_PRE_DELETE', 78007 );

  define( 'PCLZIP_CB_POST_DELETE', 78008 );

 */



// --------------------------------------------------------------------------------

// Class : PclZip

// Description :

//   PclZip is the class that represent a Zip archive.

//   The public methods allow the manipulation of the archive.

// Attributes :

//   Attributes must not be accessed directly.

// Methods :

//   PclZip() : Object creator

//   create() : Creates the Zip archive

//   listContent() : List the content of the Zip archive

//   extract() : Extract the content of the archive

//   properties() : List the properties of the archive

// --------------------------------------------------------------------------------

class PclZip {



    // ----- Filename of the zip file

    var $zipname = '';

    // ----- File descriptor of the zip file

    var $zip_fd = 0;

    // ----- Internal error handling

    var $error_code = 1;

    var $error_string = '';

    // ----- Current status of the magic_quotes_runtime

    // This value store the php configuration for magic_quotes

    // The class can then disable the magic_quotes and reset it after

    var $magic_quotes_status;



    // --------------------------------------------------------------------------------

    // Function : PclZip()

    // Description :

    //   Creates a PclZip object and set the name of the associated Zip archive

    //   filename.

    //   Note that no real action is taken, if the archive does not exist it is not

    //   created. Use create() for that.

    // --------------------------------------------------------------------------------

    function PclZip($p_zipname) {



        // ----- Tests the zlib

        if (!function_exists('gzopen')) {

            die('Abort ' . basename(__FILE__) . ' : Missing zlib extensions');

        }



        // ----- Set the attributes

        $this->zipname = $p_zipname;

        $this->zip_fd = 0;

        $this->magic_quotes_status = -1;



        // ----- Return

        return;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function :

    //   create($p_filelist, $p_add_dir="", $p_remove_dir="")

    //   create($p_filelist, $p_option, $p_option_value, ...)

    // Description :

    //   This method supports two different synopsis. The first one is historical.

    //   This method creates a Zip Archive. The Zip file is created in the

    //   filesystem. The files and directories indicated in $p_filelist

    //   are added in the archive. See the parameters description for the

    //   supported format of $p_filelist.

    //   When a directory is in the list, the directory and its content is added

    //   in the archive.

    //   In this synopsis, the function takes an optional variable list of

    //   options. See bellow the supported options.

    // Parameters :

    //   $p_filelist : An array containing file or directory names, or

    //                 a string containing one filename or one directory name, or

    //                 a string containing a list of filenames and/or directory

    //                 names separated by spaces.

    //   $p_add_dir : A path to add before the real path of the archived file,

    //                in order to have it memorized in the archive.

    //   $p_remove_dir : A path to remove from the real path of the file to archive,

    //                   in order to have a shorter path memorized in the archive.

    //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir

    //                   is removed first, before $p_add_dir is added.

    // Options :

    //   PCLZIP_OPT_ADD_PATH :

    //   PCLZIP_OPT_REMOVE_PATH :

    //   PCLZIP_OPT_REMOVE_ALL_PATH :

    //   PCLZIP_OPT_COMMENT :

    //   PCLZIP_CB_PRE_ADD :

    //   PCLZIP_CB_POST_ADD :

    // Return Values :

    //   0 on failure,

    //   The list of the added files, with a status of the add action.

    //   (see PclZip::listContent() for list entry format)

    // --------------------------------------------------------------------------------

    function create($p_filelist) {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Set default values

        $v_options = array();

        $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;



        // ----- Look for variable options arguments

        $v_size = func_num_args();



        // ----- Look for arguments

        if ($v_size > 1) {

            // ----- Get the arguments

            $v_arg_list = func_get_args();



            // ----- Remove from the options list the first argument

            array_shift($v_arg_list);

            $v_size--;



            // ----- Look for first arg

            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {



                // ----- Parse the options

                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(PCLZIP_OPT_REMOVE_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',

                    PCLZIP_OPT_ADD_PATH => 'optional',

                    PCLZIP_CB_PRE_ADD => 'optional',

                    PCLZIP_CB_POST_ADD => 'optional',

                    PCLZIP_OPT_NO_COMPRESSION => 'optional',

                    PCLZIP_OPT_COMMENT => 'optional',

                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',

                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',

                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'

                        //, PCLZIP_OPT_CRYPT => 'optional'

                ));

                if ($v_result != 1) {

                    return 0;

                }

            }



            // ----- Look for 2 args

            // Here we need to support the first historic synopsis of the

            // method.

            else {



                // ----- Get the first argument

                $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];



                // ----- Look for the optional second argument

                if ($v_size == 2) {

                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];

                } else if ($v_size > 2) {

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");

                    return 0;

                }

            }

        }



        // ----- Look for default option values

        $this->privOptionDefaultThreshold($v_options);



        // ----- Init

        $v_string_list = array();

        $v_att_list = array();

        $v_filedescr_list = array();

        $p_result_list = array();



        // ----- Look if the $p_filelist is really an array

        if (is_array($p_filelist)) {



            // ----- Look if the first element is also an array

            //       This will mean that this is a file description entry

            if (isset($p_filelist[0]) && is_array($p_filelist[0])) {

                $v_att_list = $p_filelist;

            }



            // ----- The list is a list of string names

            else {

                $v_string_list = $p_filelist;

            }

        }



        // ----- Look if the $p_filelist is a string

        else if (is_string($p_filelist)) {

            // ----- Create a list from the string

            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);

        }



        // ----- Invalid variable type for $p_filelist

        else {

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");

            return 0;

        }



        // ----- Reformat the string list

        if (sizeof($v_string_list) != 0) {

            foreach ($v_string_list as $v_string) {

                if ($v_string != '') {

                    $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;

                } else {

                    

                }

            }

        }



        // ----- For each file in the list check the attributes

        $v_supported_attributes = array(PCLZIP_ATT_FILE_NAME => 'mandatory'

            , PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'

            , PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'

            , PCLZIP_ATT_FILE_MTIME => 'optional'

            , PCLZIP_ATT_FILE_CONTENT => 'optional'

            , PCLZIP_ATT_FILE_COMMENT => 'optional'

        );

        foreach ($v_att_list as $v_entry) {

            $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);

            if ($v_result != 1) {

                return 0;

            }

        }



        // ----- Expand the filelist (expand directories)

        $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);

        if ($v_result != 1) {

            return 0;

        }



        // ----- Call the create fct

        $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);

        if ($v_result != 1) {

            return 0;

        }



        // ----- Return

        return $p_result_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function :

    //   add($p_filelist, $p_add_dir="", $p_remove_dir="")

    //   add($p_filelist, $p_option, $p_option_value, ...)

    // Description :

    //   This method supports two synopsis. The first one is historical.

    //   This methods add the list of files in an existing archive.

    //   If a file with the same name already exists, it is added at the end of the

    //   archive, the first one is still present.

    //   If the archive does not exist, it is created.

    // Parameters :

    //   $p_filelist : An array containing file or directory names, or

    //                 a string containing one filename or one directory name, or

    //                 a string containing a list of filenames and/or directory

    //                 names separated by spaces.

    //   $p_add_dir : A path to add before the real path of the archived file,

    //                in order to have it memorized in the archive.

    //   $p_remove_dir : A path to remove from the real path of the file to archive,

    //                   in order to have a shorter path memorized in the archive.

    //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir

    //                   is removed first, before $p_add_dir is added.

    // Options :

    //   PCLZIP_OPT_ADD_PATH :

    //   PCLZIP_OPT_REMOVE_PATH :

    //   PCLZIP_OPT_REMOVE_ALL_PATH :

    //   PCLZIP_OPT_COMMENT :

    //   PCLZIP_OPT_ADD_COMMENT :

    //   PCLZIP_OPT_PREPEND_COMMENT :

    //   PCLZIP_CB_PRE_ADD :

    //   PCLZIP_CB_POST_ADD :

    // Return Values :

    //   0 on failure,

    //   The list of the added files, with a status of the add action.

    //   (see PclZip::listContent() for list entry format)

    // --------------------------------------------------------------------------------

    function add($p_filelist) {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Set default values

        $v_options = array();

        $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;



        // ----- Look for variable options arguments

        $v_size = func_num_args();



        // ----- Look for arguments

        if ($v_size > 1) {

            // ----- Get the arguments

            $v_arg_list = func_get_args();



            // ----- Remove form the options list the first argument

            array_shift($v_arg_list);

            $v_size--;



            // ----- Look for first arg

            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {



                // ----- Parse the options

                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(PCLZIP_OPT_REMOVE_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',

                    PCLZIP_OPT_ADD_PATH => 'optional',

                    PCLZIP_CB_PRE_ADD => 'optional',

                    PCLZIP_CB_POST_ADD => 'optional',

                    PCLZIP_OPT_NO_COMPRESSION => 'optional',

                    PCLZIP_OPT_COMMENT => 'optional',

                    PCLZIP_OPT_ADD_COMMENT => 'optional',

                    PCLZIP_OPT_PREPEND_COMMENT => 'optional',

                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',

                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',

                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'



                        //, PCLZIP_OPT_CRYPT => 'optional'

                ));

                if ($v_result != 1) {

                    return 0;

                }

            }



            // ----- Look for 2 args

            // Here we need to support the first historic synopsis of the

            // method.

            else {



                // ----- Get the first argument

                $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];



                // ----- Look for the optional second argument

                if ($v_size == 2) {

                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];

                } else if ($v_size > 2) {

                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");



                    // ----- Return

                    return 0;

                }

            }

        }



        // ----- Look for default option values

        $this->privOptionDefaultThreshold($v_options);



        // ----- Init

        $v_string_list = array();

        $v_att_list = array();

        $v_filedescr_list = array();

        $p_result_list = array();



        // ----- Look if the $p_filelist is really an array

        if (is_array($p_filelist)) {



            // ----- Look if the first element is also an array

            //       This will mean that this is a file description entry

            if (isset($p_filelist[0]) && is_array($p_filelist[0])) {

                $v_att_list = $p_filelist;

            }



            // ----- The list is a list of string names

            else {

                $v_string_list = $p_filelist;

            }

        }



        // ----- Look if the $p_filelist is a string

        else if (is_string($p_filelist)) {

            // ----- Create a list from the string

            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);

        }



        // ----- Invalid variable type for $p_filelist

        else {

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '" . gettype($p_filelist) . "' for p_filelist");

            return 0;

        }



        // ----- Reformat the string list

        if (sizeof($v_string_list) != 0) {

            foreach ($v_string_list as $v_string) {

                $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;

            }

        }



        // ----- For each file in the list check the attributes

        $v_supported_attributes = array(PCLZIP_ATT_FILE_NAME => 'mandatory'

            , PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'

            , PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'

            , PCLZIP_ATT_FILE_MTIME => 'optional'

            , PCLZIP_ATT_FILE_CONTENT => 'optional'

            , PCLZIP_ATT_FILE_COMMENT => 'optional'

        );

        foreach ($v_att_list as $v_entry) {

            $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);

            if ($v_result != 1) {

                return 0;

            }

        }



        // ----- Expand the filelist (expand directories)

        $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);

        if ($v_result != 1) {

            return 0;

        }



        // ----- Call the create fct

        $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);

        if ($v_result != 1) {

            return 0;

        }



        // ----- Return

        return $p_result_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : listContent()

    // Description :

    //   This public method, gives the list of the files and directories, with their

    //   properties.

    //   The properties of each entries in the list are (used also in other functions) :

    //     filename : Name of the file. For a create or add action it is the filename

    //                given by the user. For an extract function it is the filename

    //                of the extracted file.

    //     stored_filename : Name of the file / directory stored in the archive.

    //     size : Size of the stored file.

    //     compressed_size : Size of the file's data compressed in the archive

    //                       (without the headers overhead)

    //     mtime : Last known modification date of the file (UNIX timestamp)

    //     comment : Comment associated with the file

    //     folder : true | false

    //     index : index of the file in the archive

    //     status : status of the action (depending of the action) :

    //              Values are :

    //                ok : OK !

    //                filtered : the file / dir is not extracted (filtered by user)

    //                already_a_directory : the file can not be extracted because a

    //                                      directory with the same name already exists

    //                write_protected : the file can not be extracted because a file

    //                                  with the same name already exists and is

    //                                  write protected

    //                newer_exist : the file was not extracted because a newer file exists

    //                path_creation_fail : the file is not extracted because the folder

    //                                     does not exist and can not be created

    //                write_error : the file was not extracted because there was a

    //                              error while writing the file

    //                read_error : the file was not extracted because there was a error

    //                             while reading the file

    //                invalid_header : the file was not extracted because of an archive

    //                                 format error (bad file header)

    //   Note that each time a method can continue operating when there

    //   is an action error on a file, the error is only logged in the file status.

    // Return Values :

    //   0 on an unrecoverable failure,

    //   The list of the files in the archive.

    // --------------------------------------------------------------------------------

    function listContent() {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            return(0);

        }



        // ----- Call the extracting fct

        $p_list = array();

        if (($v_result = $this->privList($p_list)) != 1) {

            unset($p_list);

            return(0);

        }



        // ----- Return

        return $p_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function :

    //   extract($p_path="./", $p_remove_path="")

    //   extract([$p_option, $p_option_value, ...])

    // Description :

    //   This method supports two synopsis. The first one is historical.

    //   This method extract all the files / directories from the archive to the

    //   folder indicated in $p_path.

    //   If you want to ignore the 'root' part of path of the memorized files

    //   you can indicate this in the optional $p_remove_path parameter.

    //   By default, if a newer file with the same name already exists, the

    //   file is not extracted.

    //

  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions

    //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append

    //   at the end of the path value of PCLZIP_OPT_PATH.

    // Parameters :

    //   $p_path : Path where the files and directories are to be extracted

    //   $p_remove_path : First part ('root' part) of the memorized path

    //                    (if any similar) to remove while extracting.

    // Options :

    //   PCLZIP_OPT_PATH :

    //   PCLZIP_OPT_ADD_PATH :

    //   PCLZIP_OPT_REMOVE_PATH :

    //   PCLZIP_OPT_REMOVE_ALL_PATH :

    //   PCLZIP_CB_PRE_EXTRACT :

    //   PCLZIP_CB_POST_EXTRACT :

    // Return Values :

    //   0 or a negative value on failure,

    //   The list of the extracted files, with a status of the action.

    //   (see PclZip::listContent() for list entry format)

    // --------------------------------------------------------------------------------

    function extract() {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            return(0);

        }



        // ----- Set default values

        $v_options = array();

//    $v_path = "./";

        $v_path = '';

        $v_remove_path = "";

        $v_remove_all_path = false;



        // ----- Look for variable options arguments

        $v_size = func_num_args();



        // ----- Default values for option

        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;



        // ----- Look for arguments

        if ($v_size > 0) {

            // ----- Get the arguments

            $v_arg_list = func_get_args();



            // ----- Look for first arg

            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {



                // ----- Parse the options

                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(PCLZIP_OPT_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',

                    PCLZIP_OPT_ADD_PATH => 'optional',

                    PCLZIP_CB_PRE_EXTRACT => 'optional',

                    PCLZIP_CB_POST_EXTRACT => 'optional',

                    PCLZIP_OPT_SET_CHMOD => 'optional',

                    PCLZIP_OPT_BY_NAME => 'optional',

                    PCLZIP_OPT_BY_EREG => 'optional',

                    PCLZIP_OPT_BY_PREG => 'optional',

                    PCLZIP_OPT_BY_INDEX => 'optional',

                    PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',

                    PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',

                    PCLZIP_OPT_REPLACE_NEWER => 'optional'

                    , PCLZIP_OPT_STOP_ON_ERROR => 'optional'

                    , PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',

                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',

                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',

                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'

                ));

                if ($v_result != 1) {

                    return 0;

                }



                // ----- Set the arguments

                if (isset($v_options[PCLZIP_OPT_PATH])) {

                    $v_path = $v_options[PCLZIP_OPT_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {

                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {

                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {

                    // ----- Check for '/' in last path char

                    if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {

                        $v_path .= '/';

                    }

                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];

                }

            }



            // ----- Look for 2 args

            // Here we need to support the first historic synopsis of the

            // method.

            else {



                // ----- Get the first argument

                $v_path = $v_arg_list[0];



                // ----- Look for the optional second argument

                if ($v_size == 2) {

                    $v_remove_path = $v_arg_list[1];

                } else if ($v_size > 2) {

                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");



                    // ----- Return

                    return 0;

                }

            }

        }



        // ----- Look for default option values

        $this->privOptionDefaultThreshold($v_options);



        // ----- Trace

        // ----- Call the extracting fct

        $p_list = array();

        $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options);

        if ($v_result < 1) {

            unset($p_list);

            return(0);

        }



        // ----- Return

        return $p_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function :

    //   extractByIndex($p_index, $p_path="./", $p_remove_path="")

    //   extractByIndex($p_index, [$p_option, $p_option_value, ...])

    // Description :

    //   This method supports two synopsis. The first one is historical.

    //   This method is doing a partial extract of the archive.

    //   The extracted files or folders are identified by their index in the

    //   archive (from 0 to n).

    //   Note that if the index identify a folder, only the folder entry is

    //   extracted, not all the files included in the archive.

    // Parameters :

    //   $p_index : A single index (integer) or a string of indexes of files to

    //              extract. The form of the string is "0,4-6,8-12" with only numbers

    //              and '-' for range or ',' to separate ranges. No spaces or ';'

    //              are allowed.

    //   $p_path : Path where the files and directories are to be extracted

    //   $p_remove_path : First part ('root' part) of the memorized path

    //                    (if any similar) to remove while extracting.

    // Options :

    //   PCLZIP_OPT_PATH :

    //   PCLZIP_OPT_ADD_PATH :

    //   PCLZIP_OPT_REMOVE_PATH :

    //   PCLZIP_OPT_REMOVE_ALL_PATH :

    //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and

    //     not as files.

    //     The resulting content is in a new field 'content' in the file

    //     structure.

    //     This option must be used alone (any other options are ignored).

    //   PCLZIP_CB_PRE_EXTRACT :

    //   PCLZIP_CB_POST_EXTRACT :

    // Return Values :

    //   0 on failure,

    //   The list of the extracted files, with a status of the action.

    //   (see PclZip::listContent() for list entry format)

    // --------------------------------------------------------------------------------

    //function extractByIndex($p_index, options...)

    function extractByIndex($p_index) {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            return(0);

        }



        // ----- Set default values

        $v_options = array();

//    $v_path = "./";

        $v_path = '';

        $v_remove_path = "";

        $v_remove_all_path = false;



        // ----- Look for variable options arguments

        $v_size = func_num_args();



        // ----- Default values for option

        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;



        // ----- Look for arguments

        if ($v_size > 1) {

            // ----- Get the arguments

            $v_arg_list = func_get_args();



            // ----- Remove form the options list the first argument

            array_shift($v_arg_list);

            $v_size--;



            // ----- Look for first arg

            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {



                // ----- Parse the options

                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(PCLZIP_OPT_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_PATH => 'optional',

                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',

                    PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',

                    PCLZIP_OPT_ADD_PATH => 'optional',

                    PCLZIP_CB_PRE_EXTRACT => 'optional',

                    PCLZIP_CB_POST_EXTRACT => 'optional',

                    PCLZIP_OPT_SET_CHMOD => 'optional',

                    PCLZIP_OPT_REPLACE_NEWER => 'optional'

                    , PCLZIP_OPT_STOP_ON_ERROR => 'optional'

                    , PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',

                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',

                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',

                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'

                ));

                if ($v_result != 1) {

                    return 0;

                }



                // ----- Set the arguments

                if (isset($v_options[PCLZIP_OPT_PATH])) {

                    $v_path = $v_options[PCLZIP_OPT_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {

                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {

                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];

                }

                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {

                    // ----- Check for '/' in last path char

                    if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {

                        $v_path .= '/';

                    }

                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];

                }

                if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {

                    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;

                } else {

                    

                }

            }



            // ----- Look for 2 args

            // Here we need to support the first historic synopsis of the

            // method.

            else {



                // ----- Get the first argument

                $v_path = $v_arg_list[0];



                // ----- Look for the optional second argument

                if ($v_size == 2) {

                    $v_remove_path = $v_arg_list[1];

                } else if ($v_size > 2) {

                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");



                    // ----- Return

                    return 0;

                }

            }

        }



        // ----- Trace

        // ----- Trick

        // Here I want to reuse extractByRule(), so I need to parse the $p_index

        // with privParseOptions()

        $v_arg_trick = array(PCLZIP_OPT_BY_INDEX, $p_index);

        $v_options_trick = array();

        $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick, array(PCLZIP_OPT_BY_INDEX => 'optional'));

        if ($v_result != 1) {

            return 0;

        }

        $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];



        // ----- Look for default option values

        $this->privOptionDefaultThreshold($v_options);



        // ----- Call the extracting fct

        if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {

            return(0);

        }



        // ----- Return

        return $p_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function :

    //   delete([$p_option, $p_option_value, ...])

    // Description :

    //   This method removes files from the archive.

    //   If no parameters are given, then all the archive is emptied.

    // Parameters :

    //   None or optional arguments.

    // Options :

    //   PCLZIP_OPT_BY_INDEX :

    //   PCLZIP_OPT_BY_NAME :

    //   PCLZIP_OPT_BY_EREG : 

    //   PCLZIP_OPT_BY_PREG :

    // Return Values :

    //   0 on failure,

    //   The list of the files which are still present in the archive.

    //   (see PclZip::listContent() for list entry format)

    // --------------------------------------------------------------------------------

    function delete() {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            return(0);

        }



        // ----- Set default values

        $v_options = array();



        // ----- Look for variable options arguments

        $v_size = func_num_args();



        // ----- Look for arguments

        if ($v_size > 0) {

            // ----- Get the arguments

            $v_arg_list = func_get_args();



            // ----- Parse the options

            $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(PCLZIP_OPT_BY_NAME => 'optional',

                PCLZIP_OPT_BY_EREG => 'optional',

                PCLZIP_OPT_BY_PREG => 'optional',

                PCLZIP_OPT_BY_INDEX => 'optional'));

            if ($v_result != 1) {

                return 0;

            }

        }



        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Call the delete fct

        $v_list = array();

        if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {

            $this->privSwapBackMagicQuotes();

            unset($v_list);

            return(0);

        }



        // ----- Magic quotes trick

        $this->privSwapBackMagicQuotes();



        // ----- Return

        return $v_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : deleteByIndex()

    // Description :

    //   ***** Deprecated *****

    //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.

    // --------------------------------------------------------------------------------

    function deleteByIndex($p_index) {



        $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);



        // ----- Return

        return $p_list;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : properties()

    // Description :

    //   This method gives the properties of the archive.

    //   The properties are :

    //     nb : Number of files in the archive

    //     comment : Comment associated with the archive file

    //     status : not_exist, ok

    // Parameters :

    //   None

    // Return Values :

    //   0 on failure,

    //   An array with the archive properties.

    // --------------------------------------------------------------------------------

    function properties() {



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            $this->privSwapBackMagicQuotes();

            return(0);

        }



        // ----- Default properties

        $v_prop = array();

        $v_prop['comment'] = '';

        $v_prop['nb'] = 0;

        $v_prop['status'] = 'not_exist';



        // ----- Look if file exists

        if (@is_file($this->zipname)) {

            // ----- Open the zip file

            if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0) {

                $this->privSwapBackMagicQuotes();



                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \'' . $this->zipname . '\' in binary read mode');



                // ----- Return

                return 0;

            }



            // ----- Read the central directory informations

            $v_central_dir = array();

            if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

                $this->privSwapBackMagicQuotes();

                return 0;

            }



            // ----- Close the zip file

            $this->privCloseFd();



            // ----- Set the user attributes

            $v_prop['comment'] = $v_central_dir['comment'];

            $v_prop['nb'] = $v_central_dir['entries'];

            $v_prop['status'] = 'ok';

        }



        // ----- Magic quotes trick

        $this->privSwapBackMagicQuotes();



        // ----- Return

        return $v_prop;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : duplicate()

    // Description :

    //   This method creates an archive by copying the content of an other one. If

    //   the archive already exist, it is replaced by the new one without any warning.

    // Parameters :

    //   $p_archive : The filename of a valid archive, or

    //                a valid PclZip object.

    // Return Values :

    //   1 on success.

    //   0 or a negative value on error (error code).

    // --------------------------------------------------------------------------------

    function duplicate($p_archive) {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Look if the $p_archive is a PclZip object

        if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip')) {



            // ----- Duplicate the archive

            $v_result = $this->privDuplicate($p_archive->zipname);

        }



        // ----- Look if the $p_archive is a string (so a filename)

        else if (is_string($p_archive)) {



            // ----- Check that $p_archive is a valid zip file

            // TBC : Should also check the archive format

            if (!is_file($p_archive)) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "No file with filename '" . $p_archive . "'");

                $v_result = PCLZIP_ERR_MISSING_FILE;

            } else {

                // ----- Duplicate the archive

                $v_result = $this->privDuplicate($p_archive);

            }

        }



        // ----- Invalid variable

        else {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");

            $v_result = PCLZIP_ERR_INVALID_PARAMETER;

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : merge()

    // Description :

    //   This method merge the $p_archive_to_add archive at the end of the current

    //   one ($this).

    //   If the archive ($this) does not exist, the merge becomes a duplicate.

    //   If the $p_archive_to_add archive does not exist, the merge is a success.

    // Parameters :

    //   $p_archive_to_add : It can be directly the filename of a valid zip archive,

    //                       or a PclZip object archive.

    // Return Values :

    //   1 on success,

    //   0 or negative values on error (see below).

    // --------------------------------------------------------------------------------

    function merge($p_archive_to_add) {

        $v_result = 1;



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Check archive

        if (!$this->privCheckFormat()) {

            return(0);

        }



        // ----- Look if the $p_archive_to_add is a PclZip object

        if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip')) {



            // ----- Merge the archive

            $v_result = $this->privMerge($p_archive_to_add);

        }



        // ----- Look if the $p_archive_to_add is a string (so a filename)

        else if (is_string($p_archive_to_add)) {



            // ----- Create a temporary archive

            $v_object_archive = new PclZip($p_archive_to_add);



            // ----- Merge the archive

            $v_result = $this->privMerge($v_object_archive);

        }



        // ----- Invalid variable

        else {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");

            $v_result = PCLZIP_ERR_INVALID_PARAMETER;

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : errorCode()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function errorCode() {

        if (PCLZIP_ERROR_EXTERNAL == 1) {

            return(PclErrorCode());

        } else {

            return($this->error_code);

        }

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : errorName()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function errorName($p_with_code = false) {

        $v_name = array(PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',

            PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',

            PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',

            PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',

            PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',

            PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',

            PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',

            PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',

            PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',

            PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',

            PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',

            PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',

            PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',

            PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',

            PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',

            PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',

            PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',

            PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',

            PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'

            , PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'

            , PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'

        );



        if (isset($v_name[$this->error_code])) {

            $v_value = $v_name[$this->error_code];

        } else {

            $v_value = 'NoName';

        }



        if ($p_with_code) {

            return($v_value . ' (' . $this->error_code . ')');

        } else {

            return($v_value);

        }

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : errorInfo()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function errorInfo($p_full = false) {

        if (PCLZIP_ERROR_EXTERNAL == 1) {

            return(PclErrorString());

        } else {

            if ($p_full) {

                return($this->errorName(true) . " : " . $this->error_string);

            } else {

                return($this->error_string . " [code " . $this->error_code . "]");

            }

        }

    }



    // --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****

// *****                                                        *****

// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****

// --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privCheckFormat()

    // Description :

    //   This method check that the archive exists and is a valid zip archive.

    //   Several level of check exists. (futur)

    // Parameters :

    //   $p_level : Level of check. Default 0.

    //              0 : Check the first bytes (magic codes) (default value))

    //              1 : 0 + Check the central directory (futur)

    //              2 : 1 + Check each file header (futur)

    // Return Values :

    //   true on success,

    //   false on error, the error code is set.

    // --------------------------------------------------------------------------------

    function privCheckFormat($p_level = 0) {

        $v_result = true;



        // ----- Reset the file system cache

        clearstatcache();



        // ----- Reset the error handler

        $this->privErrorReset();



        // ----- Look if the file exits

        if (!is_file($this->zipname)) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '" . $this->zipname . "'");

            return(false);

        }



        // ----- Check that the file is readeable

        if (!is_readable($this->zipname)) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '" . $this->zipname . "'");

            return(false);

        }



        // ----- Check the magic code

        // TBC

        // ----- Check the central header

        // TBC

        // ----- Check each file header

        // TBC

        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privParseOptions()

    // Description :

    //   This internal methods reads the variable list of arguments ($p_options_list,

    //   $p_size) and generate an array with the options and values ($v_result_list).

    //   $v_requested_options contains the options that can be present and those that

    //   must be present.

    //   $v_requested_options is an array, with the option value as key, and 'optional',

    //   or 'mandatory' as value.

    // Parameters :

    //   See above.

    // Return Values :

    //   1 on success.

    //   0 on failure.

    // --------------------------------------------------------------------------------

    function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options = false) {

        $v_result = 1;



        // ----- Read the options

        $i = 0;

        while ($i < $p_size) {



            // ----- Check if the option is supported

            if (!isset($v_requested_options[$p_options_list[$i]])) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '" . $p_options_list[$i] . "' for this method");



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Look for next option

            switch ($p_options_list[$i]) {

                // ----- Look for options that request a path value

                case PCLZIP_OPT_PATH :

                case PCLZIP_OPT_REMOVE_PATH :

                case PCLZIP_OPT_ADD_PATH :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i + 1], FALSE);

                    $i++;

                    break;



                case PCLZIP_OPT_TEMP_FILE_THRESHOLD :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");

                        return PclZip::errorCode();

                    }



                    // ----- Check for incompatible options

                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" . PclZipUtilOptionText($p_options_list[$i]) . "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");

                        return PclZip::errorCode();

                    }



                    // ----- Check the value

                    $v_value = $p_options_list[$i + 1];

                    if ((!is_integer($v_value)) || ($v_value < 0)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");

                        return PclZip::errorCode();

                    }



                    // ----- Get the value (and convert it in bytes)

                    $v_result_list[$p_options_list[$i]] = $v_value * 1048576;

                    $i++;

                    break;



                case PCLZIP_OPT_TEMP_FILE_ON :

                    // ----- Check for incompatible options

                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" . PclZipUtilOptionText($p_options_list[$i]) . "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");

                        return PclZip::errorCode();

                    }



                    $v_result_list[$p_options_list[$i]] = true;

                    break;



                case PCLZIP_OPT_TEMP_FILE_OFF :

                    // ----- Check for incompatible options

                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" . PclZipUtilOptionText($p_options_list[$i]) . "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");

                        return PclZip::errorCode();

                    }

                    // ----- Check for incompatible options

                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '" . PclZipUtilOptionText($p_options_list[$i]) . "' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");

                        return PclZip::errorCode();

                    }



                    $v_result_list[$p_options_list[$i]] = true;

                    break;



                case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    if (is_string($p_options_list[$i + 1]) && ($p_options_list[$i + 1] != '')) {

                        $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i + 1], FALSE);

                        $i++;

                    } else {

                        

                    }

                    break;



                // ----- Look for options that request an array of string for value

                case PCLZIP_OPT_BY_NAME :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    if (is_string($p_options_list[$i + 1])) {

                        $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i + 1];

                    } else if (is_array($p_options_list[$i + 1])) {

                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];

                    } else {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }

                    $i++;

                    break;



                // ----- Look for options that request an EREG or PREG expression

                case PCLZIP_OPT_BY_EREG :

                    // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG

                    // to PCLZIP_OPT_BY_PREG

                    $p_options_list[$i] = PCLZIP_OPT_BY_PREG;

                case PCLZIP_OPT_BY_PREG :

                    //case PCLZIP_OPT_CRYPT :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    if (is_string($p_options_list[$i + 1])) {

                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];

                    } else {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }

                    $i++;

                    break;



                // ----- Look for options that takes a string

                case PCLZIP_OPT_COMMENT :

                case PCLZIP_OPT_ADD_COMMENT :

                case PCLZIP_OPT_PREPEND_COMMENT :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '"

                                . PclZipUtilOptionText($p_options_list[$i])

                                . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    if (is_string($p_options_list[$i + 1])) {

                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];

                    } else {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '"

                                . PclZipUtilOptionText($p_options_list[$i])

                                . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }

                    $i++;

                    break;



                // ----- Look for options that request an array of index

                case PCLZIP_OPT_BY_INDEX :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    $v_work_list = array();

                    if (is_string($p_options_list[$i + 1])) {



                        // ----- Remove spaces

                        $p_options_list[$i + 1] = strtr($p_options_list[$i + 1], ' ', '');



                        // ----- Parse items

                        $v_work_list = explode(",", $p_options_list[$i + 1]);

                    } else if (is_integer($p_options_list[$i + 1])) {

                        $v_work_list[0] = $p_options_list[$i + 1] . '-' . $p_options_list[$i + 1];

                    } else if (is_array($p_options_list[$i + 1])) {

                        $v_work_list = $p_options_list[$i + 1];

                    } else {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Reduce the index list

                    // each index item in the list must be a couple with a start and

                    // an end value : [0,3], [5-5], [8-10], ...

                    // ----- Check the format of each item

                    $v_sort_flag = false;

                    $v_sort_value = 0;

                    for ($j = 0; $j < sizeof($v_work_list); $j++) {

                        // ----- Explode the item

                        $v_item_list = explode("-", $v_work_list[$j]);

                        $v_size_item_list = sizeof($v_item_list);



                        // ----- TBC : Here we might check that each item is a

                        // real integer ...

                        // ----- Look for single value

                        if ($v_size_item_list == 1) {

                            // ----- Set the option value

                            $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];

                            $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];

                        } elseif ($v_size_item_list == 2) {

                            // ----- Set the option value

                            $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];

                            $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];

                        } else {

                            // ----- Error log

                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                            // ----- Return

                            return PclZip::errorCode();

                        }





                        // ----- Look for list sort

                        if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {

                            $v_sort_flag = true;



                            // ----- TBC : An automatic sort should be writen ...

                            // ----- Error log

                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                            // ----- Return

                            return PclZip::errorCode();

                        }

                        $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];

                    }



                    // ----- Sort the items

                    if ($v_sort_flag) {

                        // TBC : To Be Completed

                    }



                    // ----- Next option

                    $i++;

                    break;



                // ----- Look for options that request no value

                case PCLZIP_OPT_REMOVE_ALL_PATH :

                case PCLZIP_OPT_EXTRACT_AS_STRING :

                case PCLZIP_OPT_NO_COMPRESSION :

                case PCLZIP_OPT_EXTRACT_IN_OUTPUT :

                case PCLZIP_OPT_REPLACE_NEWER :

                case PCLZIP_OPT_STOP_ON_ERROR :

                    $v_result_list[$p_options_list[$i]] = true;

                    break;



                // ----- Look for options that request an octal value

                case PCLZIP_OPT_SET_CHMOD :

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];

                    $i++;

                    break;



                // ----- Look for options that request a call-back

                case PCLZIP_CB_PRE_EXTRACT :

                case PCLZIP_CB_POST_EXTRACT :

                case PCLZIP_CB_PRE_ADD :

                case PCLZIP_CB_POST_ADD :

                    /* for futur use

                      case PCLZIP_CB_PRE_DELETE :

                      case PCLZIP_CB_POST_DELETE :

                      case PCLZIP_CB_PRE_LIST :

                      case PCLZIP_CB_POST_LIST :

                     */

                    // ----- Check the number of parameters

                    if (($i + 1) >= $p_size) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Get the value

                    $v_function_name = $p_options_list[$i + 1];



                    // ----- Check that the value is a valid existing function

                    if (!function_exists($v_function_name)) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '" . $v_function_name . "()' is not an existing function for option '" . PclZipUtilOptionText($p_options_list[$i]) . "'");



                        // ----- Return

                        return PclZip::errorCode();

                    }



                    // ----- Set the attribute

                    $v_result_list[$p_options_list[$i]] = $v_function_name;

                    $i++;

                    break;



                default :

                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '"

                            . $p_options_list[$i] . "'");



                    // ----- Return

                    return PclZip::errorCode();

            }



            // ----- Next options

            $i++;

        }



        // ----- Look for mandatory options

        if ($v_requested_options !== false) {

            for ($key = reset($v_requested_options); $key = key($v_requested_options); $key = next($v_requested_options)) {

                // ----- Look for mandatory option

                if ($v_requested_options[$key] == 'mandatory') {

                    // ----- Look if present

                    if (!isset($v_result_list[$key])) {

                        // ----- Error log

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " . PclZipUtilOptionText($key) . "(" . $key . ")");



                        // ----- Return

                        return PclZip::errorCode();

                    }

                }

            }

        }



        // ----- Look for default values

        if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {

            

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privOptionDefaultThreshold()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privOptionDefaultThreshold(&$p_options) {

        $v_result = 1;



        if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {

            return $v_result;

        }



        // ----- Get 'memory_limit' configuration value

        $v_memory_limit = ini_get('memory_limit');

        $v_memory_limit = trim($v_memory_limit);

        $last = strtolower(substr($v_memory_limit, -1));



        if ($last == 'g')

        //$v_memory_limit = $v_memory_limit*1024*1024*1024;

            $v_memory_limit = $v_memory_limit * 1073741824;

        if ($last == 'm')

        //$v_memory_limit = $v_memory_limit*1024*1024;

            $v_memory_limit = $v_memory_limit * 1048576;

        if ($last == 'k')

            $v_memory_limit = $v_memory_limit * 1024;



        $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit * PCLZIP_TEMPORARY_FILE_RATIO);





        // ----- Sanity check : No threshold if value lower than 1M

        if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {

            unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privFileDescrParseAtt()

    // Description :

    // Parameters :

    // Return Values :

    //   1 on success.

    //   0 on failure.

    // --------------------------------------------------------------------------------

    function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options = false) {

        $v_result = 1;



        // ----- For each file in the list check the attributes

        foreach ($p_file_list as $v_key => $v_value) {



            // ----- Check if the option is supported

            if (!isset($v_requested_options[$v_key])) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '" . $v_key . "' for this file");



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Look for attribute

            switch ($v_key) {

                case PCLZIP_ATT_FILE_NAME :

                    if (!is_string($v_value)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " . gettype($v_value) . ". String expected for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);



                    if ($p_filedescr['filename'] == '') {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    break;



                case PCLZIP_ATT_FILE_NEW_SHORT_NAME :

                    if (!is_string($v_value)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " . gettype($v_value) . ". String expected for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);



                    if ($p_filedescr['new_short_name'] == '') {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }

                    break;



                case PCLZIP_ATT_FILE_NEW_FULL_NAME :

                    if (!is_string($v_value)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " . gettype($v_value) . ". String expected for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);



                    if ($p_filedescr['new_full_name'] == '') {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }

                    break;



                // ----- Look for options that takes a string

                case PCLZIP_ATT_FILE_COMMENT :

                    if (!is_string($v_value)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " . gettype($v_value) . ". String expected for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    $p_filedescr['comment'] = $v_value;

                    break;



                case PCLZIP_ATT_FILE_MTIME :

                    if (!is_integer($v_value)) {

                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type " . gettype($v_value) . ". Integer expected for attribute '" . PclZipUtilOptionText($v_key) . "'");

                        return PclZip::errorCode();

                    }



                    $p_filedescr['mtime'] = $v_value;

                    break;



                case PCLZIP_ATT_FILE_CONTENT :

                    $p_filedescr['content'] = $v_value;

                    break;



                default :

                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" . $v_key . "'");



                    // ----- Return

                    return PclZip::errorCode();

            }



            // ----- Look for mandatory options

            if ($v_requested_options !== false) {

                for ($key = reset($v_requested_options); $key = key($v_requested_options); $key = next($v_requested_options)) {

                    // ----- Look for mandatory option

                    if ($v_requested_options[$key] == 'mandatory') {

                        // ----- Look if present

                        if (!isset($p_file_list[$key])) {

                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " . PclZipUtilOptionText($key) . "(" . $key . ")");

                            return PclZip::errorCode();

                        }

                    }

                }

            }



            // end foreach

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privFileDescrExpand()

    // Description :

    //   This method look for each item of the list to see if its a file, a folder

    //   or a string to be added as file. For any other type of files (link, other)

    //   just ignore the item.

    //   Then prepare the information that will be stored for that file.

    //   When its a folder, expand the folder with all the files that are in that 

    //   folder (recursively).

    // Parameters :

    // Return Values :

    //   1 on success.

    //   0 on failure.

    // --------------------------------------------------------------------------------

    function privFileDescrExpand(&$p_filedescr_list, &$p_options) {

        $v_result = 1;



        // ----- Create a result list

        $v_result_list = array();



        // ----- Look each entry

        for ($i = 0; $i < sizeof($p_filedescr_list); $i++) {



            // ----- Get filedescr

            $v_descr = $p_filedescr_list[$i];



            // ----- Reduce the filename

            $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);

            $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);



            // ----- Look for real file or folder

            if (file_exists($v_descr['filename'])) {

                if (@is_file($v_descr['filename'])) {

                    $v_descr['type'] = 'file';

                } else if (@is_dir($v_descr['filename'])) {

                    $v_descr['type'] = 'folder';

                } else if (@is_link($v_descr['filename'])) {

                    // skip

                    continue;

                } else {

                    // skip

                    continue;

                }

            }



            // ----- Look for string added as file

            else if (isset($v_descr['content'])) {

                $v_descr['type'] = 'virtual_file';

            }



            // ----- Missing file

            else {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '" . $v_descr['filename'] . "' does not exist");



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Calculate the stored filename

            $this->privCalculateStoredFilename($v_descr, $p_options);



            // ----- Add the descriptor in result list

            $v_result_list[sizeof($v_result_list)] = $v_descr;



            // ----- Look for folder

            if ($v_descr['type'] == 'folder') {

                // ----- List of items in folder

                $v_dirlist_descr = array();

                $v_dirlist_nb = 0;

                if ($v_folder_handler = @opendir($v_descr['filename'])) {

                    while (($v_item_handler = @readdir($v_folder_handler)) !== false) {



                        // ----- Skip '.' and '..'

                        if (($v_item_handler == '.') || ($v_item_handler == '..')) {

                            continue;

                        }



                        // ----- Compose the full filename

                        $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'] . '/' . $v_item_handler;



                        // ----- Look for different stored filename

                        // Because the name of the folder was changed, the name of the

                        // files/sub-folders also change

                        if (($v_descr['stored_filename'] != $v_descr['filename']) && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {

                            if ($v_descr['stored_filename'] != '') {

                                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'] . '/' . $v_item_handler;

                            } else {

                                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;

                            }

                        }



                        $v_dirlist_nb++;

                    }



                    @closedir($v_folder_handler);

                } else {

                    // TBC : unable to open folder in read mode

                }



                // ----- Expand each element of the list

                if ($v_dirlist_nb != 0) {

                    // ----- Expand

                    if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {

                        return $v_result;

                    }



                    // ----- Concat the resulting list

                    $v_result_list = array_merge($v_result_list, $v_dirlist_descr);

                } else {

                    

                }



                // ----- Free local array

                unset($v_dirlist_descr);

            }

        }



        // ----- Get the result list

        $p_filedescr_list = $v_result_list;



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privCreate()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privCreate($p_filedescr_list, &$p_result_list, &$p_options) {

        $v_result = 1;

        $v_list_detail = array();



        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Open the file in write mode

        if (($v_result = $this->privOpenFd('wb')) != 1) {

            // ----- Return

            return $v_result;

        }



        // ----- Add the list of files

        $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);



        // ----- Close

        $this->privCloseFd();



        // ----- Magic quotes trick

        $this->privSwapBackMagicQuotes();



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privAdd()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privAdd($p_filedescr_list, &$p_result_list, &$p_options) {

        $v_result = 1;

        $v_list_detail = array();



        // ----- Look if the archive exists or is empty

        if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0)) {



            // ----- Do a create

            $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);



            // ----- Return

            return $v_result;

        }

        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Open the zip file

        if (($v_result = $this->privOpenFd('rb')) != 1) {

            // ----- Magic quotes trick

            $this->privSwapBackMagicQuotes();



            // ----- Return

            return $v_result;

        }



        // ----- Read the central directory informations

        $v_central_dir = array();

        if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

            $this->privCloseFd();

            $this->privSwapBackMagicQuotes();

            return $v_result;

        }



        // ----- Go to beginning of File

        @rewind($this->zip_fd);



        // ----- Creates a temporay file

        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid('pclzip-') . '.tmp';



        // ----- Open the temporary file in write mode

        if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0) {

            $this->privCloseFd();

            $this->privSwapBackMagicQuotes();



            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \'' . $v_zip_temp_name . '\' in binary write mode');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Copy the files from the archive to the temporary file

        // TBC : Here I should better append the file and go back to erase the central dir

        $v_size = $v_central_dir['offset'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = fread($this->zip_fd, $v_read_size);

            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Swap the file descriptor

        // Here is a trick : I swap the temporary fd with the zip fd, in order to use

        // the following methods on the temporary fil and not the real archive

        $v_swap = $this->zip_fd;

        $this->zip_fd = $v_zip_temp_fd;

        $v_zip_temp_fd = $v_swap;



        // ----- Add the files

        $v_header_list = array();

        if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) {

            fclose($v_zip_temp_fd);

            $this->privCloseFd();

            @unlink($v_zip_temp_name);

            $this->privSwapBackMagicQuotes();



            // ----- Return

            return $v_result;

        }



        // ----- Store the offset of the central dir

        $v_offset = @ftell($this->zip_fd);



        // ----- Copy the block of file headers from the old archive

        $v_size = $v_central_dir['size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($v_zip_temp_fd, $v_read_size);

            @fwrite($this->zip_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Create the Central Dir files header

        for ($i = 0, $v_count = 0; $i < sizeof($v_header_list); $i++) {

            // ----- Create the file header

            if ($v_header_list[$i]['status'] == 'ok') {

                if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {

                    fclose($v_zip_temp_fd);

                    $this->privCloseFd();

                    @unlink($v_zip_temp_name);

                    $this->privSwapBackMagicQuotes();



                    // ----- Return

                    return $v_result;

                }

                $v_count++;

            }



            // ----- Transform the header to a 'usable' info

            $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);

        }



        // ----- Zip file comment

        $v_comment = $v_central_dir['comment'];

        if (isset($p_options[PCLZIP_OPT_COMMENT])) {

            $v_comment = $p_options[PCLZIP_OPT_COMMENT];

        }

        if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {

            $v_comment = $v_comment . $p_options[PCLZIP_OPT_ADD_COMMENT];

        }

        if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {

            $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT] . $v_comment;

        }



        // ----- Calculate the size of the central header

        $v_size = @ftell($this->zip_fd) - $v_offset;



        // ----- Create the central dir footer

        if (($v_result = $this->privWriteCentralHeader($v_count + $v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1) {

            // ----- Reset the file list

            unset($v_header_list);

            $this->privSwapBackMagicQuotes();



            // ----- Return

            return $v_result;

        }



        // ----- Swap back the file descriptor

        $v_swap = $this->zip_fd;

        $this->zip_fd = $v_zip_temp_fd;

        $v_zip_temp_fd = $v_swap;



        // ----- Close

        $this->privCloseFd();



        // ----- Close the temporary file

        @fclose($v_zip_temp_fd);



        // ----- Magic quotes trick

        $this->privSwapBackMagicQuotes();



        // ----- Delete the zip file

        // TBC : I should test the result ...

        @unlink($this->zipname);



        // ----- Rename the temporary file

        // TBC : I should test the result ...

        //@rename($v_zip_temp_name, $this->zipname);

        PclZipUtilRename($v_zip_temp_name, $this->zipname);



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privOpenFd()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function privOpenFd($p_mode) {

        $v_result = 1;



        // ----- Look if already open

        if ($this->zip_fd != 0) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \'' . $this->zipname . '\' already open');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Open the zip file

        if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \'' . $this->zipname . '\' in ' . $p_mode . ' mode');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privCloseFd()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function privCloseFd() {

        $v_result = 1;



        if ($this->zip_fd != 0)

            @fclose($this->zip_fd);

        $this->zip_fd = 0;



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privAddList()

    // Description :

    //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is

    //   different from the real path of the file. This is usefull if you want to have PclTar

    //   running in any directory, and memorize relative path from an other directory.

    // Parameters :

    //   $p_list : An array containing the file or directory names to add in the tar

    //   $p_result_list : list of added files with their properties (specially the status field)

    //   $p_add_dir : Path to add in the filename path archived

    //   $p_remove_dir : Path to remove in the filename path archived

    // Return Values :

    // --------------------------------------------------------------------------------

//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)

    function privAddList($p_filedescr_list, &$p_result_list, &$p_options) {

        $v_result = 1;



        // ----- Add the files

        $v_header_list = array();

        if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) {

            // ----- Return

            return $v_result;

        }



        // ----- Store the offset of the central dir

        $v_offset = @ftell($this->zip_fd);



        // ----- Create the Central Dir files header

        for ($i = 0, $v_count = 0; $i < sizeof($v_header_list); $i++) {

            // ----- Create the file header

            if ($v_header_list[$i]['status'] == 'ok') {

                if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {

                    // ----- Return

                    return $v_result;

                }

                $v_count++;

            }



            // ----- Transform the header to a 'usable' info

            $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);

        }



        // ----- Zip file comment

        $v_comment = '';

        if (isset($p_options[PCLZIP_OPT_COMMENT])) {

            $v_comment = $p_options[PCLZIP_OPT_COMMENT];

        }



        // ----- Calculate the size of the central header

        $v_size = @ftell($this->zip_fd) - $v_offset;



        // ----- Create the central dir footer

        if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1) {

            // ----- Reset the file list

            unset($v_header_list);



            // ----- Return

            return $v_result;

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privAddFileList()

    // Description :

    // Parameters :

    //   $p_filedescr_list : An array containing the file description 

    //                      or directory names to add in the zip

    //   $p_result_list : list of added files with their properties (specially the status field)

    // Return Values :

    // --------------------------------------------------------------------------------

    function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options) {

        $v_result = 1;

        $v_header = array();



        // ----- Recuperate the current number of elt in list

        $v_nb = sizeof($p_result_list);



        // ----- Loop on the files

        for ($j = 0; ($j < sizeof($p_filedescr_list)) && ($v_result == 1); $j++) {

            // ----- Format the filename

            $p_filedescr_list[$j]['filename'] = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);





            // ----- Skip empty file names

            // TBC : Can this be possible ? not checked in DescrParseAtt ?

            if ($p_filedescr_list[$j]['filename'] == "") {

                continue;

            }



            // ----- Check the filename

            if (($p_filedescr_list[$j]['type'] != 'virtual_file') && (!file_exists($p_filedescr_list[$j]['filename']))) {

                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '" . $p_filedescr_list[$j]['filename'] . "' does not exist");

                return PclZip::errorCode();

            }



            // ----- Look if it is a file or a dir with no all path remove option

            // or a dir with all its path removed

//      if (   (is_file($p_filedescr_list[$j]['filename']))

//          || (   is_dir($p_filedescr_list[$j]['filename'])

            if (($p_filedescr_list[$j]['type'] == 'file') || ($p_filedescr_list[$j]['type'] == 'virtual_file') || ( ($p_filedescr_list[$j]['type'] == 'folder') && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]) || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))

            ) {



                // ----- Add the file

                $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header, $p_options);

                if ($v_result != 1) {

                    return $v_result;

                }



                // ----- Store the file infos

                $p_result_list[$v_nb++] = $v_header;

            }

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privAddFile()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privAddFile($p_filedescr, &$p_header, &$p_options) {

        $v_result = 1;



        // ----- Working variable

        $p_filename = $p_filedescr['filename'];



        // TBC : Already done in the fileAtt check ... ?

        if ($p_filename == "") {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)");



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Look for a stored different filename 

        /* TBC : Removed

          if (isset($p_filedescr['stored_filename'])) {

          $v_stored_filename = $p_filedescr['stored_filename'];

          }

          else {

          $v_stored_filename = $p_filedescr['stored_filename'];

          }

         */



        // ----- Set the file properties

        clearstatcache();

        $p_header['version'] = 20;

        $p_header['version_extracted'] = 10;

        $p_header['flag'] = 0;

        $p_header['compression'] = 0;

        $p_header['crc'] = 0;

        $p_header['compressed_size'] = 0;

        $p_header['filename_len'] = strlen($p_filename);

        $p_header['extra_len'] = 0;

        $p_header['disk'] = 0;

        $p_header['internal'] = 0;

        $p_header['offset'] = 0;

        $p_header['filename'] = $p_filename;

// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;

        $p_header['stored_filename'] = $p_filedescr['stored_filename'];

        $p_header['extra'] = '';

        $p_header['status'] = 'ok';

        $p_header['index'] = -1;



        // ----- Look for regular file

        if ($p_filedescr['type'] == 'file') {

            $p_header['external'] = 0x00000000;

            $p_header['size'] = filesize($p_filename);

        }



        // ----- Look for regular folder

        else if ($p_filedescr['type'] == 'folder') {

            $p_header['external'] = 0x00000010;

            $p_header['mtime'] = filemtime($p_filename);

            $p_header['size'] = filesize($p_filename);

        }



        // ----- Look for virtual file

        else if ($p_filedescr['type'] == 'virtual_file') {

            $p_header['external'] = 0x00000000;

            $p_header['size'] = strlen($p_filedescr['content']);

        }





        // ----- Look for filetime

        if (isset($p_filedescr['mtime'])) {

            $p_header['mtime'] = $p_filedescr['mtime'];

        } else if ($p_filedescr['type'] == 'virtual_file') {

            $p_header['mtime'] = time();

        } else {

            $p_header['mtime'] = filemtime($p_filename);

        }



        // ------ Look for file comment

        if (isset($p_filedescr['comment'])) {

            $p_header['comment_len'] = strlen($p_filedescr['comment']);

            $p_header['comment'] = $p_filedescr['comment'];

        } else {

            $p_header['comment_len'] = 0;

            $p_header['comment'] = '';

        }



        // ----- Look for pre-add callback

        if (isset($p_options[PCLZIP_CB_PRE_ADD])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_header, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_ADD].'(PCLZIP_CB_PRE_ADD, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);

            if ($v_result == 0) {

                // ----- Change the file status

                $p_header['status'] = "skipped";

                $v_result = 1;

            }



            // ----- Update the informations

            // Only some fields can be modified

            if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {

                $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);

            }

        }



        // ----- Look for empty stored filename

        if ($p_header['stored_filename'] == "") {

            $p_header['status'] = "filtered";

        }



        // ----- Check the path length

        if (strlen($p_header['stored_filename']) > 0xFF) {

            $p_header['status'] = 'filename_too_long';

        }



        // ----- Look if no error, or file not skipped

        if ($p_header['status'] == 'ok') {



            // ----- Look for a file

            if ($p_filedescr['type'] == 'file') {

                // ----- Look for using temporary file to zip

                if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) )) {

                    $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);

                    if ($v_result < PCLZIP_ERR_NO_ERROR) {

                        return $v_result;

                    }

                }



                // ----- Use "in memory" zip algo

                else {



                    // ----- Open the source file

                    if (($v_file = @fopen($p_filename, "rb")) == 0) {

                        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");

                        return PclZip::errorCode();

                    }



                    // ----- Read the file content

                    $v_content = @fread($v_file, $p_header['size']);



                    // ----- Close the file

                    @fclose($v_file);



                    // ----- Calculate the CRC

                    $p_header['crc'] = @crc32($v_content);



                    // ----- Look for no compression

                    if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {

                        // ----- Set header parameters

                        $p_header['compressed_size'] = $p_header['size'];

                        $p_header['compression'] = 0;

                    }



                    // ----- Look for normal compression

                    else {

                        // ----- Compress the content

                        $v_content = @gzdeflate($v_content);



                        // ----- Set header parameters

                        $p_header['compressed_size'] = strlen($v_content);

                        $p_header['compression'] = 8;

                    }



                    // ----- Call the header generation

                    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {

                        @fclose($v_file);

                        return $v_result;

                    }



                    // ----- Write the compressed (or not) content

                    @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);

                }

            }



            // ----- Look for a virtual file (a file from string)

            else if ($p_filedescr['type'] == 'virtual_file') {



                $v_content = $p_filedescr['content'];



                // ----- Calculate the CRC

                $p_header['crc'] = @crc32($v_content);



                // ----- Look for no compression

                if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {

                    // ----- Set header parameters

                    $p_header['compressed_size'] = $p_header['size'];

                    $p_header['compression'] = 0;

                }



                // ----- Look for normal compression

                else {

                    // ----- Compress the content

                    $v_content = @gzdeflate($v_content);



                    // ----- Set header parameters

                    $p_header['compressed_size'] = strlen($v_content);

                    $p_header['compression'] = 8;

                }



                // ----- Call the header generation

                if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {

                    @fclose($v_file);

                    return $v_result;

                }



                // ----- Write the compressed (or not) content

                @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);

            }



            // ----- Look for a directory

            else if ($p_filedescr['type'] == 'folder') {

                // ----- Look for directory last '/'

                if (@substr($p_header['stored_filename'], -1) != '/') {

                    $p_header['stored_filename'] .= '/';

                }



                // ----- Set the file properties

                $p_header['size'] = 0;

                //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked

                $p_header['external'] = 0x00000010;   // Value for a folder : to be checked

                // ----- Call the header generation

                if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {

                    return $v_result;

                }

            }

        }



        // ----- Look for post-add callback

        if (isset($p_options[PCLZIP_CB_POST_ADD])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_header, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_ADD].'(PCLZIP_CB_POST_ADD, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);

            if ($v_result == 0) {

                // ----- Ignored

                $v_result = 1;

            }



            // ----- Update the informations

            // Nothing can be modified

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privAddFileUsingTempFile()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options) {

        $v_result = PCLZIP_ERR_NO_ERROR;



        // ----- Working variable

        $p_filename = $p_filedescr['filename'];





        // ----- Open the source file

        if (($v_file = @fopen($p_filename, "rb")) == 0) {

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");

            return PclZip::errorCode();

        }



        // ----- Creates a compressed temporary file

        $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid('pclzip-') . '.gz';

        if (($v_file_compressed = @gzopen($v_gzip_temp_name, "wb")) == 0) {

            fclose($v_file);

            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \'' . $v_gzip_temp_name . '\' in binary write mode');

            return PclZip::errorCode();

        }



        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks

        $v_size = filesize($p_filename);

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($v_file, $v_read_size);

            //$v_binary_data = pack('a'.$v_read_size, $v_buffer);

            @gzputs($v_file_compressed, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Close the file

        @fclose($v_file);

        @gzclose($v_file_compressed);



        // ----- Check the minimum file size

        if (filesize($v_gzip_temp_name) < 18) {

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \'' . $v_gzip_temp_name . '\' has invalid filesize - should be minimum 18 bytes');

            return PclZip::errorCode();

        }



        // ----- Extract the compressed attributes

        if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \'' . $v_gzip_temp_name . '\' in binary read mode');

            return PclZip::errorCode();

        }



        // ----- Read the gzip file header

        $v_binary_data = @fread($v_file_compressed, 10);

        $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);



        // ----- Check some parameters

        $v_data_header['os'] = bin2hex($v_data_header['os']);



        // ----- Read the gzip file footer

        @fseek($v_file_compressed, filesize($v_gzip_temp_name) - 8);

        $v_binary_data = @fread($v_file_compressed, 8);

        $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);



        // ----- Set the attributes

        $p_header['compression'] = ord($v_data_header['cm']);

        //$p_header['mtime'] = $v_data_header['mtime'];

        $p_header['crc'] = $v_data_footer['crc'];

        $p_header['compressed_size'] = filesize($v_gzip_temp_name) - 18;



        // ----- Close the file

        @fclose($v_file_compressed);



        // ----- Call the header generation

        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {

            return $v_result;

        }



        // ----- Add the compressed data

        if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \'' . $v_gzip_temp_name . '\' in binary read mode');

            return PclZip::errorCode();

        }



        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks

        fseek($v_file_compressed, 10);

        $v_size = $p_header['compressed_size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($v_file_compressed, $v_read_size);

            //$v_binary_data = pack('a'.$v_read_size, $v_buffer);

            @fwrite($this->zip_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Close the file

        @fclose($v_file_compressed);



        // ----- Unlink the temporary file

        @unlink($v_gzip_temp_name);



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privCalculateStoredFilename()

    // Description :

    //   Based on file descriptor properties and global options, this method

    //   calculate the filename that will be stored in the archive.

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privCalculateStoredFilename(&$p_filedescr, &$p_options) {

        $v_result = 1;



        // ----- Working variables

        $p_filename = $p_filedescr['filename'];

        if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {

            $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];

        } else {

            $p_add_dir = '';

        }

        if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {

            $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];

        } else {

            $p_remove_dir = '';

        }

        if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {

            $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];

        } else {

            $p_remove_all_dir = 0;

        }





        // ----- Look for full name change

        if (isset($p_filedescr['new_full_name'])) {

            // ----- Remove drive letter if any

            $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);

        }



        // ----- Look for path and/or short name change

        else {



            // ----- Look for short name change

            // Its when we cahnge just the filename but not the path

            if (isset($p_filedescr['new_short_name'])) {

                $v_path_info = pathinfo($p_filename);

                $v_dir = '';

                if ($v_path_info['dirname'] != '') {

                    $v_dir = $v_path_info['dirname'] . '/';

                }

                $v_stored_filename = $v_dir . $p_filedescr['new_short_name'];

            } else {

                // ----- Calculate the stored filename

                $v_stored_filename = $p_filename;

            }



            // ----- Look for all path to remove

            if ($p_remove_all_dir) {

                $v_stored_filename = basename($p_filename);

            }

            // ----- Look for partial path remove

            else if ($p_remove_dir != "") {

                if (substr($p_remove_dir, -1) != '/')

                    $p_remove_dir .= "/";



                if ((substr($p_filename, 0, 2) == "./") || (substr($p_remove_dir, 0, 2) == "./")) {



                    if ((substr($p_filename, 0, 2) == "./") && (substr($p_remove_dir, 0, 2) != "./")) {

                        $p_remove_dir = "./" . $p_remove_dir;

                    }

                    if ((substr($p_filename, 0, 2) != "./") && (substr($p_remove_dir, 0, 2) == "./")) {

                        $p_remove_dir = substr($p_remove_dir, 2);

                    }

                }



                $v_compare = PclZipUtilPathInclusion($p_remove_dir, $v_stored_filename);

                if ($v_compare > 0) {

                    if ($v_compare == 2) {

                        $v_stored_filename = "";

                    } else {

                        $v_stored_filename = substr($v_stored_filename, strlen($p_remove_dir));

                    }

                }

            }



            // ----- Remove drive letter if any

            $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);



            // ----- Look for path to add

            if ($p_add_dir != "") {

                if (substr($p_add_dir, -1) == "/")

                    $v_stored_filename = $p_add_dir . $v_stored_filename;

                else

                    $v_stored_filename = $p_add_dir . "/" . $v_stored_filename;

            }

        }



        // ----- Filename (reduce the path of stored name)

        $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);

        $p_filedescr['stored_filename'] = $v_stored_filename;



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privWriteFileHeader()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privWriteFileHeader(&$p_header) {

        $v_result = 1;



        // ----- Store the offset position of the file

        $p_header['offset'] = ftell($this->zip_fd);



        // ----- Transform UNIX mtime to DOS format mdate/mtime

        $v_date = getdate($p_header['mtime']);

        $v_mtime = ($v_date['hours'] << 11) + ($v_date['minutes'] << 5) + $v_date['seconds'] / 2;

        $v_mdate = (($v_date['year'] - 1980) << 9) + ($v_date['mon'] << 5) + $v_date['mday'];



        // ----- Packed data

        $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50, $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len']);



        // ----- Write the first 148 bytes of the header in the archive

        fputs($this->zip_fd, $v_binary_data, 30);



        // ----- Write the variable fields

        if (strlen($p_header['stored_filename']) != 0) {

            fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));

        }

        if ($p_header['extra_len'] != 0) {

            fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privWriteCentralFileHeader()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privWriteCentralFileHeader(&$p_header) {

        $v_result = 1;



        // TBC

        //for(reset($p_header); $key = key($p_header); next($p_header)) {

        //}

        // ----- Transform UNIX mtime to DOS format mdate/mtime

        $v_date = getdate($p_header['mtime']);

        $v_mtime = ($v_date['hours'] << 11) + ($v_date['minutes'] << 5) + $v_date['seconds'] / 2;

        $v_mdate = (($v_date['year'] - 1980) << 9) + ($v_date['mon'] << 5) + $v_date['mday'];





        // ----- Packed data

        $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50, $p_header['version'], $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len'], $p_header['comment_len'], $p_header['disk'], $p_header['internal'], $p_header['external'], $p_header['offset']);



        // ----- Write the 42 bytes of the header in the zip file

        fputs($this->zip_fd, $v_binary_data, 46);



        // ----- Write the variable fields

        if (strlen($p_header['stored_filename']) != 0) {

            fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));

        }

        if ($p_header['extra_len'] != 0) {

            fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);

        }

        if ($p_header['comment_len'] != 0) {

            fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privWriteCentralHeader()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment) {

        $v_result = 1;



        // ----- Packed data

        $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries, $p_nb_entries, $p_size, $p_offset, strlen($p_comment));



        // ----- Write the 22 bytes of the header in the zip file

        fputs($this->zip_fd, $v_binary_data, 22);



        // ----- Write the variable fields

        if (strlen($p_comment) != 0) {

            fputs($this->zip_fd, $p_comment, strlen($p_comment));

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privList()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privList(&$p_list) {

        $v_result = 1;



        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Open the zip file

        if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0) {

            // ----- Magic quotes trick

            $this->privSwapBackMagicQuotes();



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \'' . $this->zipname . '\' in binary read mode');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Read the central directory informations

        $v_central_dir = array();

        if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

            $this->privSwapBackMagicQuotes();

            return $v_result;

        }



        // ----- Go to beginning of Central Dir

        @rewind($this->zip_fd);

        if (@fseek($this->zip_fd, $v_central_dir['offset'])) {

            $this->privSwapBackMagicQuotes();



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Read each entry

        for ($i = 0; $i < $v_central_dir['entries']; $i++) {

            // ----- Read the file header

            if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1) {

                $this->privSwapBackMagicQuotes();

                return $v_result;

            }

            $v_header['index'] = $i;



            // ----- Get the only interesting attributes

            $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);

            unset($v_header);

        }



        // ----- Close the zip file

        $this->privCloseFd();



        // ----- Magic quotes trick

        $this->privSwapBackMagicQuotes();



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privConvertHeader2FileInfo()

    // Description :

    //   This function takes the file informations from the central directory

    //   entries and extract the interesting parameters that will be given back.

    //   The resulting file infos are set in the array $p_info

    //     $p_info['filename'] : Filename with full path. Given by user (add),

    //                           extracted in the filesystem (extract).

    //     $p_info['stored_filename'] : Stored filename in the archive.

    //     $p_info['size'] = Size of the file.

    //     $p_info['compressed_size'] = Compressed size of the file.

    //     $p_info['mtime'] = Last modification date of the file.

    //     $p_info['comment'] = Comment associated with the file.

    //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.

    //     $p_info['status'] = status of the action on the file.

    //     $p_info['crc'] = CRC of the file content.

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privConvertHeader2FileInfo($p_header, &$p_info) {

        $v_result = 1;



        // ----- Get the interesting attributes

        $v_temp_path = PclZipUtilPathReduction($p_header['filename']);

        $p_info['filename'] = $v_temp_path;

        $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);

        $p_info['stored_filename'] = $v_temp_path;

        $p_info['size'] = $p_header['size'];

        $p_info['compressed_size'] = $p_header['compressed_size'];

        $p_info['mtime'] = $p_header['mtime'];

        $p_info['comment'] = $p_header['comment'];

        $p_info['folder'] = (($p_header['external'] & 0x00000010) == 0x00000010);

        $p_info['index'] = $p_header['index'];

        $p_info['status'] = $p_header['status'];

        $p_info['crc'] = $p_header['crc'];



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privExtractByRule()

    // Description :

    //   Extract a file or directory depending of rules (by index, by name, ...)

    // Parameters :

    //   $p_file_list : An array where will be placed the properties of each

    //                  extracted file

    //   $p_path : Path to add while writing the extracted files

    //   $p_remove_path : Path to remove (from the file memorized path) while writing the

    //                    extracted files. If the path does not match the file path,

    //                    the file is extracted with its memorized path.

    //                    $p_remove_path does not apply to 'list' mode.

    //                    $p_path and $p_remove_path are commulative.

    // Return Values :

    //   1 on success,0 or less on error (see error code list)

    // --------------------------------------------------------------------------------

    function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options) {

        $v_result = 1;



        // ----- Magic quotes trick

        $this->privDisableMagicQuotes();



        // ----- Check the path

        if (($p_path == "") || ( (substr($p_path, 0, 1) != "/") && (substr($p_path, 0, 3) != "../") && (substr($p_path, 1, 2) != ":/")))

            $p_path = "./" . $p_path;



        // ----- Reduce the path last (and duplicated) '/'

        if (($p_path != "./") && ($p_path != "/")) {

            // ----- Look for the path end '/'

            while (substr($p_path, -1) == "/") {

                $p_path = substr($p_path, 0, strlen($p_path) - 1);

            }

        }



        // ----- Look for path to remove format (should end by /)

        if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/')) {

            $p_remove_path .= '/';

        }

        $p_remove_path_size = strlen($p_remove_path);



        // ----- Open the zip file

        if (($v_result = $this->privOpenFd('rb')) != 1) {

            $this->privSwapBackMagicQuotes();

            return $v_result;

        }



        // ----- Read the central directory informations

        $v_central_dir = array();

        if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

            // ----- Close the zip file

            $this->privCloseFd();

            $this->privSwapBackMagicQuotes();



            return $v_result;

        }



        // ----- Start at beginning of Central Dir

        $v_pos_entry = $v_central_dir['offset'];



        // ----- Read each entry

        $j_start = 0;

        for ($i = 0, $v_nb_extracted = 0; $i < $v_central_dir['entries']; $i++) {



            // ----- Read next Central dir entry

            @rewind($this->zip_fd);

            if (@fseek($this->zip_fd, $v_pos_entry)) {

                // ----- Close the zip file

                $this->privCloseFd();

                $this->privSwapBackMagicQuotes();



                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Read the file header

            $v_header = array();

            if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1) {

                // ----- Close the zip file

                $this->privCloseFd();

                $this->privSwapBackMagicQuotes();



                return $v_result;

            }



            // ----- Store the index

            $v_header['index'] = $i;



            // ----- Store the file position

            $v_pos_entry = ftell($this->zip_fd);



            // ----- Look for the specific extract rules

            $v_extract = false;



            // ----- Look for extract by name rule

            if ((isset($p_options[PCLZIP_OPT_BY_NAME])) && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {



                // ----- Look if the filename is in the list

                for ($j = 0; ($j < sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {



                    // ----- Look for a directory

                    if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {



                        // ----- Look if the directory is in the filename path

                        if ((strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {

                            $v_extract = true;

                        }

                    }

                    // ----- Look for a filename

                    elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {

                        $v_extract = true;

                    }

                }

            }



            // ----- Look for extract by ereg rule

            // ereg() is deprecated with PHP 5.3

            /*

              else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))

              && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {



              if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {

              $v_extract = true;

              }

              }

             */



            // ----- Look for extract by preg rule

            else if ((isset($p_options[PCLZIP_OPT_BY_PREG])) && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {



                if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {

                    $v_extract = true;

                }

            }



            // ----- Look for extract by index rule

            else if ((isset($p_options[PCLZIP_OPT_BY_INDEX])) && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {



                // ----- Look if the index is in the list

                for ($j = $j_start; ($j < sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {



                    if (($i >= $p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i <= $p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {

                        $v_extract = true;

                    }

                    if ($i >= $p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {

                        $j_start = $j + 1;

                    }



                    if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start'] > $i) {

                        break;

                    }

                }

            }



            // ----- Look for no rule, which means extract all the archive

            else {

                $v_extract = true;

            }



            // ----- Check compression method

            if (($v_extract) && ( ($v_header['compression'] != 8) && ($v_header['compression'] != 0))) {

                $v_header['status'] = 'unsupported_compression';



                // ----- Look for PCLZIP_OPT_STOP_ON_ERROR

                if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {



                    $this->privSwapBackMagicQuotes();



                    PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, "Filename '" . $v_header['stored_filename'] . "' is "

                            . "compressed by an unsupported compression "

                            . "method (" . $v_header['compression'] . ") ");



                    return PclZip::errorCode();

                }

            }



            // ----- Check encrypted files

            if (($v_extract) && (($v_header['flag'] & 1) == 1)) {

                $v_header['status'] = 'unsupported_encryption';



                // ----- Look for PCLZIP_OPT_STOP_ON_ERROR

                if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {



                    $this->privSwapBackMagicQuotes();



                    PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "Unsupported encryption for "

                            . " filename '" . $v_header['stored_filename']

                            . "'");



                    return PclZip::errorCode();

                }

            }



            // ----- Look for real extraction

            if (($v_extract) && ($v_header['status'] != 'ok')) {

                $v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++]);

                if ($v_result != 1) {

                    $this->privCloseFd();

                    $this->privSwapBackMagicQuotes();

                    return $v_result;

                }



                $v_extract = false;

            }



            // ----- Look for real extraction

            if ($v_extract) {



                // ----- Go to the file position

                @rewind($this->zip_fd);

                if (@fseek($this->zip_fd, $v_header['offset'])) {

                    // ----- Close the zip file

                    $this->privCloseFd();



                    $this->privSwapBackMagicQuotes();



                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');



                    // ----- Return

                    return PclZip::errorCode();

                }



                // ----- Look for extraction as string

                if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {



                    $v_string = '';



                    // ----- Extracting the file

                    $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);

                    if ($v_result1 < 1) {

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();

                        return $v_result1;

                    }



                    // ----- Get the only interesting attributes

                    if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1) {

                        // ----- Close the zip file

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();



                        return $v_result;

                    }



                    // ----- Set the file content

                    $p_file_list[$v_nb_extracted]['content'] = $v_string;



                    // ----- Next extracted file

                    $v_nb_extracted++;



                    // ----- Look for user callback abort

                    if ($v_result1 == 2) {

                        break;

                    }

                }

                // ----- Look for extraction in standard output

                elseif ((isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {

                    // ----- Extracting the file in standard output

                    $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);

                    if ($v_result1 < 1) {

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();

                        return $v_result1;

                    }



                    // ----- Get the only interesting attributes

                    if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();

                        return $v_result;

                    }



                    // ----- Look for user callback abort

                    if ($v_result1 == 2) {

                        break;

                    }

                }

                // ----- Look for normal extraction

                else {

                    // ----- Extracting the file

                    $v_result1 = $this->privExtractFile($v_header, $p_path, $p_remove_path, $p_remove_all_path, $p_options);

                    if ($v_result1 < 1) {

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();

                        return $v_result1;

                    }



                    // ----- Get the only interesting attributes

                    if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {

                        // ----- Close the zip file

                        $this->privCloseFd();

                        $this->privSwapBackMagicQuotes();



                        return $v_result;

                    }



                    // ----- Look for user callback abort

                    if ($v_result1 == 2) {

                        break;

                    }

                }

            }

        }



        // ----- Close the zip file

        $this->privCloseFd();

        $this->privSwapBackMagicQuotes();



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privExtractFile()

    // Description :

    // Parameters :

    // Return Values :

    //

  // 1 : ... ?

    // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback

    // --------------------------------------------------------------------------------

    function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options) {

        $v_result = 1;



        // ----- Read the file header

        if (($v_result = $this->privReadFileHeader($v_header)) != 1) {

            // ----- Return

            return $v_result;

        }





        // ----- Check that the file header is coherent with $p_entry info

        if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {

            // TBC

        }



        // ----- Look for all path to remove

        if ($p_remove_all_path == true) {

            // ----- Look for folder entry that not need to be extracted

            if (($p_entry['external'] & 0x00000010) == 0x00000010) {



                $p_entry['status'] = "filtered";



                return $v_result;

            }



            // ----- Get the basename of the path

            $p_entry['filename'] = basename($p_entry['filename']);

        }



        // ----- Look for path to remove

        else if ($p_remove_path != "") {

            if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2) {



                // ----- Change the file status

                $p_entry['status'] = "filtered";



                // ----- Return

                return $v_result;

            }



            $p_remove_path_size = strlen($p_remove_path);

            if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path) {



                // ----- Remove the path

                $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);

            }

        }



        // ----- Add the path

        if ($p_path != '') {

            $p_entry['filename'] = $p_path . "/" . $p_entry['filename'];

        }



        // ----- Check a base_dir_restriction

        if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {

            $v_inclusion = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], $p_entry['filename']);

            if ($v_inclusion == 0) {



                PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION, "Filename '" . $p_entry['filename'] . "' is "

                        . "outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION");



                return PclZip::errorCode();

            }

        }



        // ----- Look for pre-extract callback

        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);

            if ($v_result == 0) {

                // ----- Change the file status

                $p_entry['status'] = "skipped";

                $v_result = 1;

            }



            // ----- Look for abort result

            if ($v_result == 2) {

                // ----- This status is internal and will be changed in 'skipped'

                $p_entry['status'] = "aborted";

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }



            // ----- Update the informations

            // Only some fields can be modified

            $p_entry['filename'] = $v_local_header['filename'];

        }





        // ----- Look if extraction should be done

        if ($p_entry['status'] == 'ok') {



            // ----- Look for specific actions while the file exist

            if (file_exists($p_entry['filename'])) {



                // ----- Look if file is a directory

                if (is_dir($p_entry['filename'])) {



                    // ----- Change the file status

                    $p_entry['status'] = "already_a_directory";



                    // ----- Look for PCLZIP_OPT_STOP_ON_ERROR

                    // For historical reason first PclZip implementation does not stop

                    // when this kind of error occurs.

                    if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {



                        PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY, "Filename '" . $p_entry['filename'] . "' is "

                                . "already used by an existing directory");



                        return PclZip::errorCode();

                    }

                }

                // ----- Look if file is write protected

                else if (!is_writeable($p_entry['filename'])) {



                    // ----- Change the file status

                    $p_entry['status'] = "write_protected";



                    // ----- Look for PCLZIP_OPT_STOP_ON_ERROR

                    // For historical reason first PclZip implementation does not stop

                    // when this kind of error occurs.

                    if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {



                        PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Filename '" . $p_entry['filename'] . "' exists "

                                . "and is write protected");



                        return PclZip::errorCode();

                    }

                }



                // ----- Look if the extracted file is older

                else if (filemtime($p_entry['filename']) > $p_entry['mtime']) {

                    // ----- Change the file status

                    if ((isset($p_options[PCLZIP_OPT_REPLACE_NEWER])) && ($p_options[PCLZIP_OPT_REPLACE_NEWER] === true)) {

                        

                    } else {

                        $p_entry['status'] = "newer_exist";



                        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR

                        // For historical reason first PclZip implementation does not stop

                        // when this kind of error occurs.

                        if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {



                            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Newer version of '" . $p_entry['filename'] . "' exists "

                                    . "and option PCLZIP_OPT_REPLACE_NEWER is not selected");



                            return PclZip::errorCode();

                        }

                    }

                } else {

                    

                }

            }



            // ----- Check the directory availability and create it if necessary

            else {

                if ((($p_entry['external'] & 0x00000010) == 0x00000010) || (substr($p_entry['filename'], -1) == '/'))

                    $v_dir_to_check = $p_entry['filename'];

                else if (!strstr($p_entry['filename'], "/"))

                    $v_dir_to_check = "";

                else

                    $v_dir_to_check = dirname($p_entry['filename']);



                if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external'] & 0x00000010) == 0x00000010))) != 1) {



                    // ----- Change the file status

                    $p_entry['status'] = "path_creation_fail";



                    // ----- Return

                    //return $v_result;

                    $v_result = 1;

                }

            }

        }



        // ----- Look if extraction should be done

        if ($p_entry['status'] == 'ok') {



            // ----- Do the extraction (if not a folder)

            if (!(($p_entry['external'] & 0x00000010) == 0x00000010)) {

                // ----- Look for not compressed file

                if ($p_entry['compression'] == 0) {



                    // ----- Opening destination file

                    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {



                        // ----- Change the file status

                        $p_entry['status'] = "write_error";



                        // ----- Return

                        return $v_result;

                    }





                    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks

                    $v_size = $p_entry['compressed_size'];

                    while ($v_size != 0) {

                        $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

                        $v_buffer = @fread($this->zip_fd, $v_read_size);

                        /* Try to speed up the code

                          $v_binary_data = pack('a'.$v_read_size, $v_buffer);

                          @fwrite($v_dest_file, $v_binary_data, $v_read_size);

                         */

                        @fwrite($v_dest_file, $v_buffer, $v_read_size);

                        $v_size -= $v_read_size;

                    }



                    // ----- Closing the destination file

                    fclose($v_dest_file);



                    // ----- Change the file mtime

                    touch($p_entry['filename'], $p_entry['mtime']);

                } else {

                    // ----- TBC

                    // Need to be finished

                    if (($p_entry['flag'] & 1) == 1) {

                        PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \'' . $p_entry['filename'] . '\' is encrypted. Encrypted files are not supported.');

                        return PclZip::errorCode();

                    }





                    // ----- Look for using temporary file to unzip

                    if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) )) {

                        $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);

                        if ($v_result < PCLZIP_ERR_NO_ERROR) {

                            return $v_result;

                        }

                    }



                    // ----- Look for extract in memory

                    else {





                        // ----- Read the compressed file in a buffer (one shot)

                        $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);



                        // ----- Decompress the file

                        $v_file_content = @gzinflate($v_buffer);

                        unset($v_buffer);

                        if ($v_file_content === FALSE) {



                            // ----- Change the file status

                            // TBC

                            $p_entry['status'] = "error";



                            return $v_result;

                        }



                        // ----- Opening destination file

                        if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {



                            // ----- Change the file status

                            $p_entry['status'] = "write_error";



                            return $v_result;

                        }



                        // ----- Write the uncompressed data

                        @fwrite($v_dest_file, $v_file_content, $p_entry['size']);

                        unset($v_file_content);



                        // ----- Closing the destination file

                        @fclose($v_dest_file);

                    }



                    // ----- Change the file mtime

                    @touch($p_entry['filename'], $p_entry['mtime']);

                }



                // ----- Look for chmod option

                if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {



                    // ----- Change the mode of the file

                    @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);

                }

            }

        }



        // ----- Change abort status

        if ($p_entry['status'] == "aborted") {

            $p_entry['status'] = "skipped";

        }



        // ----- Look for post-extract callback

        elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);



            // ----- Look for abort result

            if ($v_result == 2) {

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privExtractFileUsingTempFile()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privExtractFileUsingTempFile(&$p_entry, &$p_options) {

        $v_result = 1;



        // ----- Creates a temporary file

        $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid('pclzip-') . '.gz';

        if (($v_dest_file = @fopen($v_gzip_temp_name, "wb")) == 0) {

            fclose($v_file);

            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \'' . $v_gzip_temp_name . '\' in binary write mode');

            return PclZip::errorCode();

        }





        // ----- Write gz file format header

        $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));

        @fwrite($v_dest_file, $v_binary_data, 10);



        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks

        $v_size = $p_entry['compressed_size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($this->zip_fd, $v_read_size);

            //$v_binary_data = pack('a'.$v_read_size, $v_buffer);

            @fwrite($v_dest_file, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Write gz file format footer

        $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);

        @fwrite($v_dest_file, $v_binary_data, 8);



        // ----- Close the temporary file

        @fclose($v_dest_file);



        // ----- Opening destination file

        if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {

            $p_entry['status'] = "write_error";

            return $v_result;

        }



        // ----- Open the temporary gz file

        if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {

            @fclose($v_dest_file);

            $p_entry['status'] = "read_error";

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \'' . $v_gzip_temp_name . '\' in binary read mode');

            return PclZip::errorCode();

        }





        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks

        $v_size = $p_entry['size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @gzread($v_src_file, $v_read_size);

            //$v_binary_data = pack('a'.$v_read_size, $v_buffer);

            @fwrite($v_dest_file, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }

        @fclose($v_dest_file);

        @gzclose($v_src_file);



        // ----- Delete the temporary file

        @unlink($v_gzip_temp_name);



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privExtractFileInOutput()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privExtractFileInOutput(&$p_entry, &$p_options) {

        $v_result = 1;



        // ----- Read the file header

        if (($v_result = $this->privReadFileHeader($v_header)) != 1) {

            return $v_result;

        }





        // ----- Check that the file header is coherent with $p_entry info

        if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {

            // TBC

        }



        // ----- Look for pre-extract callback

        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);

            if ($v_result == 0) {

                // ----- Change the file status

                $p_entry['status'] = "skipped";

                $v_result = 1;

            }



            // ----- Look for abort result

            if ($v_result == 2) {

                // ----- This status is internal and will be changed in 'skipped'

                $p_entry['status'] = "aborted";

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }



            // ----- Update the informations

            // Only some fields can be modified

            $p_entry['filename'] = $v_local_header['filename'];

        }



        // ----- Trace

        // ----- Look if extraction should be done

        if ($p_entry['status'] == 'ok') {



            // ----- Do the extraction (if not a folder)

            if (!(($p_entry['external'] & 0x00000010) == 0x00000010)) {

                // ----- Look for not compressed file

                if ($p_entry['compressed_size'] == $p_entry['size']) {



                    // ----- Read the file in a buffer (one shot)

                    $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);



                    // ----- Send the file to the output

                    echo $v_buffer;

                    unset($v_buffer);

                } else {



                    // ----- Read the compressed file in a buffer (one shot)

                    $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);



                    // ----- Decompress the file

                    $v_file_content = gzinflate($v_buffer);

                    unset($v_buffer);



                    // ----- Send the file to the output

                    echo $v_file_content;

                    unset($v_file_content);

                }

            }

        }



        // ----- Change abort status

        if ($p_entry['status'] == "aborted") {

            $p_entry['status'] = "skipped";

        }



        // ----- Look for post-extract callback

        elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);



            // ----- Look for abort result

            if ($v_result == 2) {

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }

        }



        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privExtractFileAsString()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privExtractFileAsString(&$p_entry, &$p_string, &$p_options) {

        $v_result = 1;



        // ----- Read the file header

        $v_header = array();

        if (($v_result = $this->privReadFileHeader($v_header)) != 1) {

            // ----- Return

            return $v_result;

        }





        // ----- Check that the file header is coherent with $p_entry info

        if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {

            // TBC

        }



        // ----- Look for pre-extract callback

        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();

            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);

            if ($v_result == 0) {

                // ----- Change the file status

                $p_entry['status'] = "skipped";

                $v_result = 1;

            }



            // ----- Look for abort result

            if ($v_result == 2) {

                // ----- This status is internal and will be changed in 'skipped'

                $p_entry['status'] = "aborted";

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }



            // ----- Update the informations

            // Only some fields can be modified

            $p_entry['filename'] = $v_local_header['filename'];

        }





        // ----- Look if extraction should be done

        if ($p_entry['status'] == 'ok') {



            // ----- Do the extraction (if not a folder)

            if (!(($p_entry['external'] & 0x00000010) == 0x00000010)) {

                // ----- Look for not compressed file

                //      if ($p_entry['compressed_size'] == $p_entry['size'])

                if ($p_entry['compression'] == 0) {



                    // ----- Reading the file

                    $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);

                } else {



                    // ----- Reading the file

                    $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);



                    // ----- Decompress the file

                    if (($p_string = @gzinflate($v_data)) === FALSE) {

                        // TBC

                    }

                }



                // ----- Trace

            } else {

                // TBC : error : can not extract a folder in a string

            }

        }



        // ----- Change abort status

        if ($p_entry['status'] == "aborted") {

            $p_entry['status'] = "skipped";

        }



        // ----- Look for post-extract callback

        elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {



            // ----- Generate a local information

            $v_local_header = array();



            $this->privConvertHeader2FileInfo($p_entry, $v_local_header);



            // ----- Swap the content to header

            $v_local_header['content'] = $p_string;

            $p_string = '';



            // ----- Call the callback

            // Here I do not use call_user_func() because I need to send a reference to the

            // header.

//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');

            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);



            // ----- Swap back the content to header

            $p_string = $v_local_header['content'];

            unset($v_local_header['content']);



            // ----- Look for abort result

            if ($v_result == 2) {

                $v_result = PCLZIP_ERR_USER_ABORTED;

            }

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privReadFileHeader()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privReadFileHeader(&$p_header) {

        $v_result = 1;



        // ----- Read the 4 bytes signature

        $v_binary_data = @fread($this->zip_fd, 4);

        $v_data = unpack('Vid', $v_binary_data);



        // ----- Check signature

        if ($v_data['id'] != 0x04034b50) {



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Read the first 42 bytes of the header

        $v_binary_data = fread($this->zip_fd, 26);



        // ----- Look for invalid block size

        if (strlen($v_binary_data) != 26) {

            $p_header['filename'] = "";

            $p_header['status'] = "invalid_header";



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " . strlen($v_binary_data));



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Extract the values

        $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);



        // ----- Get filename

        $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);



        // ----- Get extra_fields

        if ($v_data['extra_len'] != 0) {

            $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);

        } else {

            $p_header['extra'] = '';

        }



        // ----- Extract properties

        $p_header['version_extracted'] = $v_data['version'];

        $p_header['compression'] = $v_data['compression'];

        $p_header['size'] = $v_data['size'];

        $p_header['compressed_size'] = $v_data['compressed_size'];

        $p_header['crc'] = $v_data['crc'];

        $p_header['flag'] = $v_data['flag'];

        $p_header['filename_len'] = $v_data['filename_len'];



        // ----- Recuperate date in UNIX format

        $p_header['mdate'] = $v_data['mdate'];

        $p_header['mtime'] = $v_data['mtime'];

        if ($p_header['mdate'] && $p_header['mtime']) {

            // ----- Extract time

            $v_hour = ($p_header['mtime'] & 0xF800) >> 11;

            $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;

            $v_seconde = ($p_header['mtime'] & 0x001F) * 2;



            // ----- Extract date

            $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;

            $v_month = ($p_header['mdate'] & 0x01E0) >> 5;

            $v_day = $p_header['mdate'] & 0x001F;



            // ----- Get UNIX date format

            $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);

        } else {

            $p_header['mtime'] = time();

        }



        // TBC

        //for(reset($v_data); $key = key($v_data); next($v_data)) {

        //}

        // ----- Set the stored filename

        $p_header['stored_filename'] = $p_header['filename'];



        // ----- Set the status field

        $p_header['status'] = "ok";



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privReadCentralFileHeader()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privReadCentralFileHeader(&$p_header) {

        $v_result = 1;



        // ----- Read the 4 bytes signature

        $v_binary_data = @fread($this->zip_fd, 4);

        $v_data = unpack('Vid', $v_binary_data);



        // ----- Check signature

        if ($v_data['id'] != 0x02014b50) {



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Read the first 42 bytes of the header

        $v_binary_data = fread($this->zip_fd, 42);



        // ----- Look for invalid block size

        if (strlen($v_binary_data) != 42) {

            $p_header['filename'] = "";

            $p_header['status'] = "invalid_header";



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : " . strlen($v_binary_data));



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Extract the values

        $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);



        // ----- Get filename

        if ($p_header['filename_len'] != 0)

            $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);

        else

            $p_header['filename'] = '';



        // ----- Get extra

        if ($p_header['extra_len'] != 0)

            $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);

        else

            $p_header['extra'] = '';



        // ----- Get comment

        if ($p_header['comment_len'] != 0)

            $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);

        else

            $p_header['comment'] = '';



        // ----- Extract properties

        // ----- Recuperate date in UNIX format

        //if ($p_header['mdate'] && $p_header['mtime'])

        // TBC : bug : this was ignoring time with 0/0/0

        if (1) {

            // ----- Extract time

            $v_hour = ($p_header['mtime'] & 0xF800) >> 11;

            $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;

            $v_seconde = ($p_header['mtime'] & 0x001F) * 2;



            // ----- Extract date

            $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;

            $v_month = ($p_header['mdate'] & 0x01E0) >> 5;

            $v_day = $p_header['mdate'] & 0x001F;



            // ----- Get UNIX date format

            $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);

        } else {

            $p_header['mtime'] = time();

        }



        // ----- Set the stored filename

        $p_header['stored_filename'] = $p_header['filename'];



        // ----- Set default status to ok

        $p_header['status'] = 'ok';



        // ----- Look if it is a directory

        if (substr($p_header['filename'], -1) == '/') {

            //$p_header['external'] = 0x41FF0010;

            $p_header['external'] = 0x00000010;

        }





        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privCheckFileHeaders()

    // Description :

    // Parameters :

    // Return Values :

    //   1 on success,

    //   0 on error;

    // --------------------------------------------------------------------------------

    function privCheckFileHeaders(&$p_local_header, &$p_central_header) {

        $v_result = 1;



        // ----- Check the static values

        // TBC

        if ($p_local_header['filename'] != $p_central_header['filename']) {

            

        }

        if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {

            

        }

        if ($p_local_header['flag'] != $p_central_header['flag']) {

            

        }

        if ($p_local_header['compression'] != $p_central_header['compression']) {

            

        }

        if ($p_local_header['mtime'] != $p_central_header['mtime']) {

            

        }

        if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {

            

        }



        // ----- Look for flag bit 3

        if (($p_local_header['flag'] & 8) == 8) {

            $p_local_header['size'] = $p_central_header['size'];

            $p_local_header['compressed_size'] = $p_central_header['compressed_size'];

            $p_local_header['crc'] = $p_central_header['crc'];

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privReadEndCentralDir()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privReadEndCentralDir(&$p_central_dir) {

        $v_result = 1;



        // ----- Go to the end of the zip file

        $v_size = filesize($this->zipname);

        @fseek($this->zip_fd, $v_size);

        if (@ftell($this->zip_fd) != $v_size) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \'' . $this->zipname . '\'');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- First try : look if this is an archive with no commentaries (most of the time)

        // in this case the end of central dir is at 22 bytes of the file end

        $v_found = 0;

        if ($v_size > 26) {

            @fseek($this->zip_fd, $v_size - 22);

            if (($v_pos = @ftell($this->zip_fd)) != ($v_size - 22)) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \'' . $this->zipname . '\'');



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Read for bytes

            $v_binary_data = @fread($this->zip_fd, 4);

            $v_data = @unpack('Vid', $v_binary_data);



            // ----- Check signature

            if ($v_data['id'] == 0x06054b50) {

                $v_found = 1;

            }



            $v_pos = ftell($this->zip_fd);

        }



        // ----- Go back to the maximum possible size of the Central Dir End Record

        if (!$v_found) {

            $v_maximum_size = 65557; // 0xFFFF + 22;

            if ($v_maximum_size > $v_size)

                $v_maximum_size = $v_size;

            @fseek($this->zip_fd, $v_size - $v_maximum_size);

            if (@ftell($this->zip_fd) != ($v_size - $v_maximum_size)) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \'' . $this->zipname . '\'');



                // ----- Return

                return PclZip::errorCode();

            }



            // ----- Read byte per byte in order to find the signature

            $v_pos = ftell($this->zip_fd);

            $v_bytes = 0x00000000;

            while ($v_pos < $v_size) {

                // ----- Read a byte

                $v_byte = @fread($this->zip_fd, 1);



                // -----  Add the byte

                //$v_bytes = ($v_bytes << 8) | Ord($v_byte);

                // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number 

                // Otherwise on systems where we have 64bit integers the check below for the magic number will fail. 

                $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);



                // ----- Compare the bytes

                if ($v_bytes == 0x504b0506) {

                    $v_pos++;

                    break;

                }



                $v_pos++;

            }



            // ----- Look if not found end of central dir

            if ($v_pos == $v_size) {



                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");



                // ----- Return

                return PclZip::errorCode();

            }

        }



        // ----- Read the first 18 bytes of the header

        $v_binary_data = fread($this->zip_fd, 18);



        // ----- Look for invalid block size

        if (strlen($v_binary_data) != 18) {



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : " . strlen($v_binary_data));



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Extract the values

        $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);



        // ----- Check the global size

        if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {



            // ----- Removed in release 2.2 see readme file

            // The check of the file size is a little too strict.

            // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.

            // While decrypted, zip has training 0 bytes

            if (0) {

                // ----- Error log

                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'The central dir is not at the end of the archive.'

                        . ' Some trailing bytes exists after the archive.');



                // ----- Return

                return PclZip::errorCode();

            }

        }



        // ----- Get comment

        if ($v_data['comment_size'] != 0) {

            $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);

        } else

            $p_central_dir['comment'] = '';



        $p_central_dir['entries'] = $v_data['entries'];

        $p_central_dir['disk_entries'] = $v_data['disk_entries'];

        $p_central_dir['offset'] = $v_data['offset'];

        $p_central_dir['size'] = $v_data['size'];

        $p_central_dir['disk'] = $v_data['disk'];

        $p_central_dir['disk_start'] = $v_data['disk_start'];



        // TBC

        //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {

        //}

        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privDeleteByRule()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privDeleteByRule(&$p_result_list, &$p_options) {

        $v_result = 1;

        $v_list_detail = array();



        // ----- Open the zip file

        if (($v_result = $this->privOpenFd('rb')) != 1) {

            // ----- Return

            return $v_result;

        }



        // ----- Read the central directory informations

        $v_central_dir = array();

        if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

            $this->privCloseFd();

            return $v_result;

        }



        // ----- Go to beginning of File

        @rewind($this->zip_fd);



        // ----- Scan all the files

        // ----- Start at beginning of Central Dir

        $v_pos_entry = $v_central_dir['offset'];

        @rewind($this->zip_fd);

        if (@fseek($this->zip_fd, $v_pos_entry)) {

            // ----- Close the zip file

            $this->privCloseFd();



            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Read each entry

        $v_header_list = array();

        $j_start = 0;

        for ($i = 0, $v_nb_extracted = 0; $i < $v_central_dir['entries']; $i++) {



            // ----- Read the file header

            $v_header_list[$v_nb_extracted] = array();

            if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1) {

                // ----- Close the zip file

                $this->privCloseFd();



                return $v_result;

            }





            // ----- Store the index

            $v_header_list[$v_nb_extracted]['index'] = $i;



            // ----- Look for the specific extract rules

            $v_found = false;



            // ----- Look for extract by name rule

            if ((isset($p_options[PCLZIP_OPT_BY_NAME])) && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {



                // ----- Look if the filename is in the list

                for ($j = 0; ($j < sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {



                    // ----- Look for a directory

                    if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {



                        // ----- Look if the directory is in the filename path

                        if ((strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {

                            $v_found = true;

                        } elseif ((($v_header_list[$v_nb_extracted]['external'] & 0x00000010) == 0x00000010) /* Indicates a folder */ && ($v_header_list[$v_nb_extracted]['stored_filename'] . '/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {

                            $v_found = true;

                        }

                    }

                    // ----- Look for a filename

                    elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {

                        $v_found = true;

                    }

                }

            }



            // ----- Look for extract by ereg rule

            // ereg() is deprecated with PHP 5.3

            /*

              else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))

              && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {



              if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {

              $v_found = true;

              }

              }

             */



            // ----- Look for extract by preg rule

            else if ((isset($p_options[PCLZIP_OPT_BY_PREG])) && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {



                if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {

                    $v_found = true;

                }

            }



            // ----- Look for extract by index rule

            else if ((isset($p_options[PCLZIP_OPT_BY_INDEX])) && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {



                // ----- Look if the index is in the list

                for ($j = $j_start; ($j < sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {



                    if (($i >= $p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i <= $p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {

                        $v_found = true;

                    }

                    if ($i >= $p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {

                        $j_start = $j + 1;

                    }



                    if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start'] > $i) {

                        break;

                    }

                }

            } else {

                $v_found = true;

            }



            // ----- Look for deletion

            if ($v_found) {

                unset($v_header_list[$v_nb_extracted]);

            } else {

                $v_nb_extracted++;

            }

        }



        // ----- Look if something need to be deleted

        if ($v_nb_extracted > 0) {



            // ----- Creates a temporay file

            $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid('pclzip-') . '.tmp';



            // ----- Creates a temporary zip archive

            $v_temp_zip = new PclZip($v_zip_temp_name);



            // ----- Open the temporary zip file in write mode

            if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {

                $this->privCloseFd();



                // ----- Return

                return $v_result;

            }



            // ----- Look which file need to be kept

            for ($i = 0; $i < sizeof($v_header_list); $i++) {



                // ----- Calculate the position of the header

                @rewind($this->zip_fd);

                if (@fseek($this->zip_fd, $v_header_list[$i]['offset'])) {

                    // ----- Close the zip file

                    $this->privCloseFd();

                    $v_temp_zip->privCloseFd();

                    @unlink($v_zip_temp_name);



                    // ----- Error log

                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');



                    // ----- Return

                    return PclZip::errorCode();

                }



                // ----- Read the file header

                $v_local_header = array();

                if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {

                    // ----- Close the zip file

                    $this->privCloseFd();

                    $v_temp_zip->privCloseFd();

                    @unlink($v_zip_temp_name);



                    // ----- Return

                    return $v_result;

                }



                // ----- Check that local file header is same as central file header

                if ($this->privCheckFileHeaders($v_local_header, $v_header_list[$i]) != 1) {

                    // TBC

                }

                unset($v_local_header);



                // ----- Write the file header

                if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {

                    // ----- Close the zip file

                    $this->privCloseFd();

                    $v_temp_zip->privCloseFd();

                    @unlink($v_zip_temp_name);



                    // ----- Return

                    return $v_result;

                }



                // ----- Read/write the data block

                if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {

                    // ----- Close the zip file

                    $this->privCloseFd();

                    $v_temp_zip->privCloseFd();

                    @unlink($v_zip_temp_name);



                    // ----- Return

                    return $v_result;

                }

            }



            // ----- Store the offset of the central dir

            $v_offset = @ftell($v_temp_zip->zip_fd);



            // ----- Re-Create the Central Dir files header

            for ($i = 0; $i < sizeof($v_header_list); $i++) {

                // ----- Create the file header

                if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {

                    $v_temp_zip->privCloseFd();

                    $this->privCloseFd();

                    @unlink($v_zip_temp_name);



                    // ----- Return

                    return $v_result;

                }



                // ----- Transform the header to a 'usable' info

                $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);

            }





            // ----- Zip file comment

            $v_comment = '';

            if (isset($p_options[PCLZIP_OPT_COMMENT])) {

                $v_comment = $p_options[PCLZIP_OPT_COMMENT];

            }



            // ----- Calculate the size of the central header

            $v_size = @ftell($v_temp_zip->zip_fd) - $v_offset;



            // ----- Create the central dir footer

            if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {

                // ----- Reset the file list

                unset($v_header_list);

                $v_temp_zip->privCloseFd();

                $this->privCloseFd();

                @unlink($v_zip_temp_name);



                // ----- Return

                return $v_result;

            }



            // ----- Close

            $v_temp_zip->privCloseFd();

            $this->privCloseFd();



            // ----- Delete the zip file

            // TBC : I should test the result ...

            @unlink($this->zipname);



            // ----- Rename the temporary file

            // TBC : I should test the result ...

            //@rename($v_zip_temp_name, $this->zipname);

            PclZipUtilRename($v_zip_temp_name, $this->zipname);



            // ----- Destroy the temporary archive

            unset($v_temp_zip);

        }



        // ----- Remove every files : reset the file

        else if ($v_central_dir['entries'] != 0) {

            $this->privCloseFd();



            if (($v_result = $this->privOpenFd('wb')) != 1) {

                return $v_result;

            }



            if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {

                return $v_result;

            }



            $this->privCloseFd();

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privDirCheck()

    // Description :

    //   Check if a directory exists, if not it creates it and all the parents directory

    //   which may be useful.

    // Parameters :

    //   $p_dir : Directory path to check.

    // Return Values :

    //    1 : OK

    //   -1 : Unable to create directory

    // --------------------------------------------------------------------------------

    function privDirCheck($p_dir, $p_is_dir = false) {

        $v_result = 1;





        // ----- Remove the final '/'

        if (($p_is_dir) && (substr($p_dir, -1) == '/')) {

            $p_dir = substr($p_dir, 0, strlen($p_dir) - 1);

        }



        // ----- Check the directory availability

        if ((is_dir($p_dir)) || ($p_dir == "")) {

            return 1;

        }



        // ----- Extract parent directory

        $p_parent_dir = dirname($p_dir);



        // ----- Just a check

        if ($p_parent_dir != $p_dir) {

            // ----- Look for parent directory

            if ($p_parent_dir != "") {

                if (($v_result = $this->privDirCheck($p_parent_dir)) != 1) {

                    return $v_result;

                }

            }

        }



        // ----- Create the directory

        if (!@mkdir($p_dir, 0777)) {

            // ----- Error log

            PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privMerge()

    // Description :

    //   If $p_archive_to_add does not exist, the function exit with a success result.

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privMerge(&$p_archive_to_add) {

        $v_result = 1;



        // ----- Look if the archive_to_add exists

        if (!is_file($p_archive_to_add->zipname)) {



            // ----- Nothing to merge, so merge is a success

            $v_result = 1;



            // ----- Return

            return $v_result;

        }



        // ----- Look if the archive exists

        if (!is_file($this->zipname)) {



            // ----- Do a duplicate

            $v_result = $this->privDuplicate($p_archive_to_add->zipname);



            // ----- Return

            return $v_result;

        }



        // ----- Open the zip file

        if (($v_result = $this->privOpenFd('rb')) != 1) {

            // ----- Return

            return $v_result;

        }



        // ----- Read the central directory informations

        $v_central_dir = array();

        if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {

            $this->privCloseFd();

            return $v_result;

        }



        // ----- Go to beginning of File

        @rewind($this->zip_fd);



        // ----- Open the archive_to_add file

        if (($v_result = $p_archive_to_add->privOpenFd('rb')) != 1) {

            $this->privCloseFd();



            // ----- Return

            return $v_result;

        }



        // ----- Read the central directory informations

        $v_central_dir_to_add = array();

        if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1) {

            $this->privCloseFd();

            $p_archive_to_add->privCloseFd();



            return $v_result;

        }



        // ----- Go to beginning of File

        @rewind($p_archive_to_add->zip_fd);



        // ----- Creates a temporay file

        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid('pclzip-') . '.tmp';



        // ----- Open the temporary file in write mode

        if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0) {

            $this->privCloseFd();

            $p_archive_to_add->privCloseFd();



            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \'' . $v_zip_temp_name . '\' in binary write mode');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Copy the files from the archive to the temporary file

        // TBC : Here I should better append the file and go back to erase the central dir

        $v_size = $v_central_dir['offset'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = fread($this->zip_fd, $v_read_size);

            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Copy the files from the archive_to_add into the temporary file

        $v_size = $v_central_dir_to_add['offset'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);

            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Store the offset of the central dir

        $v_offset = @ftell($v_zip_temp_fd);



        // ----- Copy the block of file headers from the old archive

        $v_size = $v_central_dir['size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($this->zip_fd, $v_read_size);

            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Copy the block of file headers from the archive_to_add

        $v_size = $v_central_dir_to_add['size'];

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);

            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Merge the file comments

        $v_comment = $v_central_dir['comment'] . ' ' . $v_central_dir_to_add['comment'];



        // ----- Calculate the size of the (new) central header

        $v_size = @ftell($v_zip_temp_fd) - $v_offset;



        // ----- Swap the file descriptor

        // Here is a trick : I swap the temporary fd with the zip fd, in order to use

        // the following methods on the temporary fil and not the real archive fd

        $v_swap = $this->zip_fd;

        $this->zip_fd = $v_zip_temp_fd;

        $v_zip_temp_fd = $v_swap;



        // ----- Create the central dir footer

        if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries'] + $v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1) {

            $this->privCloseFd();

            $p_archive_to_add->privCloseFd();

            @fclose($v_zip_temp_fd);

            $this->zip_fd = null;



            // ----- Reset the file list

            unset($v_header_list);



            // ----- Return

            return $v_result;

        }



        // ----- Swap back the file descriptor

        $v_swap = $this->zip_fd;

        $this->zip_fd = $v_zip_temp_fd;

        $v_zip_temp_fd = $v_swap;



        // ----- Close

        $this->privCloseFd();

        $p_archive_to_add->privCloseFd();



        // ----- Close the temporary file

        @fclose($v_zip_temp_fd);



        // ----- Delete the zip file

        // TBC : I should test the result ...

        @unlink($this->zipname);



        // ----- Rename the temporary file

        // TBC : I should test the result ...

        //@rename($v_zip_temp_name, $this->zipname);

        PclZipUtilRename($v_zip_temp_name, $this->zipname);



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privDuplicate()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privDuplicate($p_archive_filename) {

        $v_result = 1;



        // ----- Look if the $p_archive_filename exists

        if (!is_file($p_archive_filename)) {



            // ----- Nothing to duplicate, so duplicate is a success.

            $v_result = 1;



            // ----- Return

            return $v_result;

        }



        // ----- Open the zip file

        if (($v_result = $this->privOpenFd('wb')) != 1) {

            // ----- Return

            return $v_result;

        }



        // ----- Open the temporary file in write mode

        if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0) {

            $this->privCloseFd();



            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \'' . $p_archive_filename . '\' in binary write mode');



            // ----- Return

            return PclZip::errorCode();

        }



        // ----- Copy the files from the archive to the temporary file

        // TBC : Here I should better append the file and go back to erase the central dir

        $v_size = filesize($p_archive_filename);

        while ($v_size != 0) {

            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = fread($v_zip_temp_fd, $v_read_size);

            @fwrite($this->zip_fd, $v_buffer, $v_read_size);

            $v_size -= $v_read_size;

        }



        // ----- Close

        $this->privCloseFd();



        // ----- Close the temporary file

        @fclose($v_zip_temp_fd);



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privErrorLog()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function privErrorLog($p_error_code = 0, $p_error_string = '') {

        if (PCLZIP_ERROR_EXTERNAL == 1) {

            PclError($p_error_code, $p_error_string);

        } else {

            $this->error_code = $p_error_code;

            $this->error_string = $p_error_string;

        }

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privErrorReset()

    // Description :

    // Parameters :

    // --------------------------------------------------------------------------------

    function privErrorReset() {

        if (PCLZIP_ERROR_EXTERNAL == 1) {

            PclErrorReset();

        } else {

            $this->error_code = 0;

            $this->error_string = '';

        }

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privDisableMagicQuotes()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privDisableMagicQuotes() {

        $v_result = 1;



        // ----- Look if function exists

        if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) {

            return $v_result;

        }



        // ----- Look if already done

        if ($this->magic_quotes_status != -1) {

            return $v_result;

        }



        // ----- Get and memorize the magic_quote value

        $this->magic_quotes_status = @get_magic_quotes_runtime();



        // ----- Disable magic_quotes

        if ($this->magic_quotes_status == 1) {

            @set_magic_quotes_runtime(0);

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------

    // Function : privSwapBackMagicQuotes()

    // Description :

    // Parameters :

    // Return Values :

    // --------------------------------------------------------------------------------

    function privSwapBackMagicQuotes() {

        $v_result = 1;



        // ----- Look if function exists

        if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) {

            return $v_result;

        }



        // ----- Look if something to do

        if ($this->magic_quotes_status != -1) {

            return $v_result;

        }



        // ----- Swap back magic_quotes

        if ($this->magic_quotes_status == 1) {

            @set_magic_quotes_runtime($this->magic_quotes_status);

        }



        // ----- Return

        return $v_result;

    }



    // --------------------------------------------------------------------------------

}



// End of class

// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilPathReduction()

// Description :

// Parameters :

// Return Values :

// --------------------------------------------------------------------------------

function PclZipUtilPathReduction($p_dir) {

    $v_result = "";



    // ----- Look for not empty path

    if ($p_dir != "") {

        // ----- Explode path by directory names

        $v_list = explode("/", $p_dir);



        // ----- Study directories from last to first

        $v_skip = 0;

        for ($i = sizeof($v_list) - 1; $i >= 0; $i--) {

            // ----- Look for current path

            if ($v_list[$i] == ".") {

                // ----- Ignore this directory

                // Should be the first $i=0, but no check is done

            } else if ($v_list[$i] == "..") {

                $v_skip++;

            } else if ($v_list[$i] == "") {

                // ----- First '/' i.e. root slash

                if ($i == 0) {

                    $v_result = "/" . $v_result;

                    if ($v_skip > 0) {

                        // ----- It is an invalid path, so the path is not modified

                        // TBC

                        $v_result = $p_dir;

                        $v_skip = 0;

                    }

                }

                // ----- Last '/' i.e. indicates a directory

                else if ($i == (sizeof($v_list) - 1)) {

                    $v_result = $v_list[$i];

                }

                // ----- Double '/' inside the path

                else {

                    // ----- Ignore only the double '//' in path,

                    // but not the first and last '/'

                }

            } else {

                // ----- Look for item to skip

                if ($v_skip > 0) {

                    $v_skip--;

                } else {

                    $v_result = $v_list[$i] . ($i != (sizeof($v_list) - 1) ? "/" . $v_result : "");

                }

            }

        }



        // ----- Look for skip

        if ($v_skip > 0) {

            while ($v_skip > 0) {

                $v_result = '../' . $v_result;

                $v_skip--;

            }

        }

    }



    // ----- Return

    return $v_result;

}



// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilPathInclusion()

// Description :

//   This function indicates if the path $p_path is under the $p_dir tree. Or,

//   said in an other way, if the file or sub-dir $p_path is inside the dir

//   $p_dir.

//   The function indicates also if the path is exactly the same as the dir.

//   This function supports path with duplicated '/' like '//', but does not

//   support '.' or '..' statements.

// Parameters :

// Return Values :

//   0 if $p_path is not inside directory $p_dir

//   1 if $p_path is inside directory $p_dir

//   2 if $p_path is exactly the same as $p_dir

// --------------------------------------------------------------------------------

function PclZipUtilPathInclusion($p_dir, $p_path) {

    $v_result = 1;



    // ----- Look for path beginning by ./

    if (($p_dir == '.') || ((strlen($p_dir) >= 2) && (substr($p_dir, 0, 2) == './'))) {

        $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE) . '/' . substr($p_dir, 1);

    }

    if (($p_path == '.') || ((strlen($p_path) >= 2) && (substr($p_path, 0, 2) == './'))) {

        $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE) . '/' . substr($p_path, 1);

    }



    // ----- Explode dir and path by directory separator

    $v_list_dir = explode("/", $p_dir);

    $v_list_dir_size = sizeof($v_list_dir);

    $v_list_path = explode("/", $p_path);

    $v_list_path_size = sizeof($v_list_path);



    // ----- Study directories paths

    $i = 0;

    $j = 0;

    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {



        // ----- Look for empty dir (path reduction)

        if ($v_list_dir[$i] == '') {

            $i++;

            continue;

        }

        if ($v_list_path[$j] == '') {

            $j++;

            continue;

        }



        // ----- Compare the items

        if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != '')) {

            $v_result = 0;

        }



        // ----- Next items

        $i++;

        $j++;

    }



    // ----- Look if everything seems to be the same

    if ($v_result) {

        // ----- Skip all the empty items

        while (($j < $v_list_path_size) && ($v_list_path[$j] == ''))

            $j++;

        while (($i < $v_list_dir_size) && ($v_list_dir[$i] == ''))

            $i++;



        if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {

            // ----- There are exactly the same

            $v_result = 2;

        } else if ($i < $v_list_dir_size) {

            // ----- The path is shorter than the dir

            $v_result = 0;

        }

    }



    // ----- Return

    return $v_result;

}



// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilCopyBlock()

// Description :

// Parameters :

//   $p_mode : read/write compression mode

//             0 : src & dest normal

//             1 : src gzip, dest normal

//             2 : src normal, dest gzip

//             3 : src & dest gzip

// Return Values :

// --------------------------------------------------------------------------------

function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode = 0) {

    $v_result = 1;



    if ($p_mode == 0) {

        while ($p_size != 0) {

            $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($p_src, $v_read_size);

            @fwrite($p_dest, $v_buffer, $v_read_size);

            $p_size -= $v_read_size;

        }

    } else if ($p_mode == 1) {

        while ($p_size != 0) {

            $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @gzread($p_src, $v_read_size);

            @fwrite($p_dest, $v_buffer, $v_read_size);

            $p_size -= $v_read_size;

        }

    } else if ($p_mode == 2) {

        while ($p_size != 0) {

            $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @fread($p_src, $v_read_size);

            @gzwrite($p_dest, $v_buffer, $v_read_size);

            $p_size -= $v_read_size;

        }

    } else if ($p_mode == 3) {

        while ($p_size != 0) {

            $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);

            $v_buffer = @gzread($p_src, $v_read_size);

            @gzwrite($p_dest, $v_buffer, $v_read_size);

            $p_size -= $v_read_size;

        }

    }



    // ----- Return

    return $v_result;

}



// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilRename()

// Description :

//   This function tries to do a simple rename() function. If it fails, it

//   tries to copy the $p_src file in a new $p_dest file and then unlink the

//   first one.

// Parameters :

//   $p_src : Old filename

//   $p_dest : New filename

// Return Values :

//   1 on success, 0 on failure.

// --------------------------------------------------------------------------------

function PclZipUtilRename($p_src, $p_dest) {

    $v_result = 1;



    // ----- Try to rename the files

    if (!@rename($p_src, $p_dest)) {



        // ----- Try to copy & unlink the src

        if (!@copy($p_src, $p_dest)) {

            $v_result = 0;

        } else if (!@unlink($p_src)) {

            $v_result = 0;

        }

    }



    // ----- Return

    return $v_result;

}



// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilOptionText()

// Description :

//   Translate option value in text. Mainly for debug purpose.

// Parameters :

//   $p_option : the option value.

// Return Values :

//   The option text value.

// --------------------------------------------------------------------------------

function PclZipUtilOptionText($p_option) {



    $v_list = get_defined_constants();

    for (reset($v_list); $v_key = key($v_list); next($v_list)) {

        $v_prefix = substr($v_key, 0, 10);

        if (( ($v_prefix == 'PCLZIP_OPT') || ($v_prefix == 'PCLZIP_CB_') || ($v_prefix == 'PCLZIP_ATT')) && ($v_list[$v_key] == $p_option)) {

            return $v_key;

        }

    }



    $v_result = 'Unknown';



    return $v_result;

}



// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------

// Function : PclZipUtilTranslateWinPath()

// Description :

//   Translate windows path by replacing '\' by '/' and optionally removing

//   drive letter.

// Parameters :

//   $p_path : path to translate.

//   $p_remove_disk_letter : true | false

// Return Values :

//   The path translated.

// --------------------------------------------------------------------------------

function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter = true) {

    if (stristr(php_uname(), 'windows')) {

        // ----- Look for potential disk letter

        if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {

            $p_path = substr($p_path, $v_position + 1);

        }

        // ----- Change potential windows directory separator

        if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0, 1) == '\\')) {

            $p_path = strtr($p_path, '\\', '/');

        }

    }

    return $p_path;

}



// --------------------------------------------------------------------------------













function salvaFile($CosaSalvare, $dove) {  // Legge i file (remoti e non)

    $a = fopen($dove, "w+");

    fwrite($a, $CosaSalvare);

    fclose($a);

}



function contenutoCartella($percorso) {

    $contenuto = null;

    $i = 0;

    if ($handle = @opendir($percorso)) {

        while (false !== ($file = readdir($handle))) {

            if ($file != "." && $file != "..") {

                $contenuto[$i] = $file;

                $i++;

            }

        }

        closedir($handle);

    }

    return $contenuto;

}



function eliminaCartella($dir) {

    $handle = opendir($dir);

    while (false !== ($FolderOrFile = readdir($handle))) {

        if ($FolderOrFile != "." && $FolderOrFile != "..") {

            if (is_dir("$dir/$FolderOrFile")) {

                eliminaCartella("$dir/$FolderOrFile");

            } else {

                unlink("$dir/$FolderOrFile");

            }

        }

    }

    closedir($handle);

    if (rmdir($dir)) {

        $success = true;

    }

    return $success;

}



function forceDownload($path, $name) {

    header('Pragma: private');

    header('Cache-control: private, must-revalidate');

    header("Content-Type: application/octet-stream");

    header("Content-Length: " . (string) (filesize($path)));

    header('Content-Disposition: attachment; filename="' . ($name) . '"');

    readfile($path);

    exit;

}



/* * ******	LOGIN FATTO ALLA BONA	********** */



function isLogOn() {

    if (@$_COOKIE['importCookie'] == "7VCGO788L57IFA41S7RJPTFM64UJSYES3S1IOPK87IRGCS7CALMEJHLGXAL0JJ2J")

        return 1;

    else

        setLog();

}



function setLog() {

    if (@$_POST['name'] == "cane" && @$_POST['password'] == "pazzo") {

        setcookie("importCookie", "7VCGO788L57IFA41S7RJPTFM64UJSYES3S1IOPK87IRGCS7CALMEJHLGXAL0JJ2J", time() + 3600 * 24 * 365);

        header("Location: iprt.php");

    }

}



$loged = isLogOn();



if (@$_COOKIE['mess']) {

    $message = $_COOKIE['mess'];

    setcookie("mess");

}



function dirList($directory, $sortOrder = 0) {



    //Get each file and add its details to two arrays

    $results = array();

    $handler = opendir($directory);

    while ($file = readdir($handler)) {

        if ($file != '.' && $file != '..' && $file != "robots.txt" && $file != ".htaccess" && !is_dir($directory . "/" . $file)) {

            $currentModified = filectime($directory . "/" . $file);

            $file_names[] = $file;

            $file_dates[] = $currentModified;

        }

    }

    closedir($handler);



    //Sort the date array by preferred order

    if ($sortOrder == "newestFirst") {

        rsort($file_dates,SORT_REGULAR);

    } else {

	  rsort($file_dates, SORT_REGULAR);

    }



    //Match file_names array to file_dates array

    $file_names_Array = array_keys($file_dates);

    foreach ($file_names_Array as $idx => $name)

        $name = $file_names[$name];

    $file_dates = array_merge($file_dates);



    $i = 0;

    //Loop through dates array and then echo the list

    foreach ($file_dates as $file_dates) {

        $date = $file_dates;

        $j = $file_names_Array[$i];

        $file = $file_names[$j];

        $i++;



        //@$dateList[$i][0]=$date;

        @$dateList[$i - 1] = $file;

    }



    return $dateList;

}



@mkdir(".bkp");

@mkdir(".bkp/note");



/* * ******	EFFETTUO BACKUP	********** */

if (@$_POST['doBackup'] || @$_GET['doBackup']) {

    $mainDir = contenutoCartella(".");

    $elementiBackup = @dirList(".bkp");

	@rsort($elementiBackup,SORT_REGULAR);

	

    if (count($mainDir) <= 3)

        setcookie("mess", "NON  STATO EFFETTUATO ALCUN BACKUP<br />

		POICH NON SONO PRESENTI FILES SUL SERVER.", time() + 180);

    else

    if (file_exists(".bkp/Backup " . date("d-m-Y") . " ore " . date("H.i") . ".zip"))

        setcookie("mess", " STATO RIVELATO UN BACKUP RECENTE. <br />

		ATTENDERE QUALCHE SECONDO PRIMA DI EFFETTUARNE UNO NUOVO.", time() + 180);

    else {

        if (@!$_POST['evDes'])

            $archive = new PclZip(".bkp/Backup " . date("d-m-Y") . " ore " . date("H.i") . ".zip");

        else

            $archive = new PclZip(".bkp/" . $_POST['evDes'] . ".zip");

        for ($i = 0; $i < count($mainDir); $i++) {

            if ($mainDir[$i] != ".bkp" && $mainDir[$i] != "iprt.php") {

                $v_list = $archive->add($mainDir[$i]);

            }

        }



        setcookie("mess", "BACKUP COMPLETATO CON SUCCESSO", time() + 180);

    }

    header("Location: iprt.php");

}



/* * ******	RIPRISTINO DA BACKUP	********** */

if (@$_POST['restoreBackup']) {

    $mainDir = contenutoCartella(".");

    $elementiBackup = @dirList(".bkp");

	rsort($elementiBackup,SORT_REGULAR);

    for ($i = 0; $i < count($mainDir); $i++) {

        if ($mainDir[$i] != ".bkp" && $mainDir[$i] != "iprt.php") {

            if (is_dir($mainDir[$i]))

                eliminaCartella($mainDir[$i]);

            else

                @unlink($mainDir[$i]);

        }

    }



    $archive = new PclZip(".bkp/" . $elementiBackup[$_POST['restoreBackup'] - 1]);



    if ($archive->extract(PCLZIP_OPT_PATH, '.', PCLZIP_OPT_REMOVE_PATH, '.temp_folder') == 0)

        die("Error : " . $archive->errorInfo(true));

    else {

        setcookie("mess", "IL BACKUP  STATO RIPRISTINATO CON SUCCESSO", time() + 180);

        header("Location: iprt.php");

    }

}



/* * ******	DOWNLOAD DA BACKUP	********** */

if (@$_POST['downloadBackup']) {

    $mainDir = contenutoCartella(".");

    $elementiBackup = @dirList(".bkp");

	rsort($elementiBackup,SORT_REGULAR);

	

    forceDownload(".bkp/" . $elementiBackup[$_POST['downloadBackup'] - 1], $elementiBackup[$_POST['downloadBackup'] - 1]);

}

/* * ******	ELIMINAZIONE BACKUP	********** */

if (@$_POST['delBackup']) {

    $mainDir = contenutoCartella(".");

    $elementiBackup = @dirList(".bkp");

	rsort($elementiBackup,SORT_REGULAR);

    unlink(".bkp/" . $elementiBackup[$_POST['delBackup'] - 1]);

    setcookie("mess", "IL FILE  STATO RIMOSSO CON SUCCESSO", time() + 180);

    header("Location: iprt.php");

}



/* * ******	UPLOAD BACKUP	********** */

if (isset($_FILES['userFile'])) {

    $tempPos = $_FILES['userFile']['tmp_name'];



    $filename = urlencode($_POST['desc']);



    while (file_exists(".bkp/" . $filename . ".zip")) {

        $filename.="+";

    }



    $destPos = ".bkp/" . $filename . ".zip";

    move_uploaded_file($tempPos, $destPos);

    setcookie("mess", "IL FILE  STATO CARICATO CON SUCCESSO", time() + 180);

    header("Location: iprt.php");

}



/* * ******	AGGIORNAMENTO NOTE	********** */

if (!file_exists(".bkp/note/note.txt"))

    salvaFile("0", ".bkp/note/i.txt");



if (@$_POST['saveNoteI']) {



    $i = file_get_contents(".bkp/note/i.txt");

    $i++;

    salvaFile($i, ".bkp/note/i.txt");

    $oldNote = @file_get_contents(".bkp/note/note.txt");

    salvaFile($oldNote, ".bkp/note/note_" . $i . ".txt");

    salvaFile(urldecode($_POST['saveNoteI']), ".bkp/note/note.txt");





    header("Location: iprt.php");

}







//		PATCH DATABASE





if (@$_POST['patch'] && @$_POST['nameFile']) {

	if(file_exists($_POST['nameFile'])){

		$dbName=explode(".",$_POST['nameFile']);

		$dbName=$dbName[0];

		$connection=new PDO("mysql:host=localhost;","root","");

		$ps=$connection->prepare("DROP DATABASE `".$dbName."`;CREATE DATABASE `".$dbName."`;");

		$ps->execute();

		$query=file_get_contents($_POST['nameFile']);

		$ps=$connection->prepare("USE `".$dbName."`;".$query);

		$ps->execute();

		setcookie("mess", "PATCH DATABASE ESEGUITA", time() + 180);

	}

	else

		setcookie("mess", "Impossibile eseguire patch.<br>Il file sorgente non esiste.", time() + 180);

    header("Location: iprt.php");



}

elseif (!file_exists("include/php/classes/DBConnection.php") && @$_POST['patch']) {

    echo "<h2><span style='color:#009'>IMPOSSIBILE APPLICARE LA PATCH<br><small>DBConnection.php non trovato</small></span></h2>";

}

?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Importer<?php if (!$loged) echo ' - LOGIN' ?></title>

        <style>img{cursor:pointer;}.buttons td{width:33%;text-align:center;}</style>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js">

        </script>

        <script>

            /* NicEdit - Micro Inline WYSIWYG

             * Copyright 2007-2008 Brian Kirchoff

             *

             * NicEdit is distributed under the terms of the MIT license

             * For more information visit http://nicedit.com/

             * Do not remove this copyright message

             */

            var bkExtend = function() {

                var A = arguments;

                if (A.length == 1) {

                    A = [this, A[0]]

                }

                for (var B in A[1]) {

                    A[0][B] = A[1][B]

                }

                return A[0]

            };

            function bkClass() {

            }

            bkClass.prototype.construct = function() {

            };

            bkClass.extend = function(C) {

                var A = function() {

                    if (arguments[0] !== bkClass) {

                        return this.construct.apply(this, arguments)

                    }

                };

                var B = new this(bkClass);

                bkExtend(B, C);

                A.prototype = B;

                A.extend = this.extend;

                return A

            };

            var bkElement = bkClass.extend({construct: function(B, A) {

                    if (typeof (B) == "string") {

                        B = (A || document).createElement(B)

                    }

                    B = $BK(B);

                    return B

                }, appendTo: function(A) {

                    A.appendChild(this);

                    return this

                }, appendBefore: function(A) {

                    A.parentNode.insertBefore(this, A);

                    return this

                }, addEvent: function(B, A) {

                    bkLib.addEvent(this, B, A);

                    return this

                }, setContent: function(A) {

                    this.innerHTML = A;

                    return this

                }, pos: function() {

                    var C = curtop = 0;

                    var B = obj = this;

                    if (obj.offsetParent) {

                        do {

                            C += obj.offsetLeft;

                            curtop += obj.offsetTop

                        } while (obj = obj.offsetParent)

                    }

                    var A = (!window.opera) ? parseInt(this.getStyle("border-width") || this.style.border) || 0 : 0;

                    return[C + A, curtop + A + this.offsetHeight]

                }, noSelect: function() {

                    bkLib.noSelect(this);

                    return this

                }, parentTag: function(A) {

                    var B = this;

                    do {

                        if (B && B.nodeName && B.nodeName.toUpperCase() == A) {

                            return B

                        }

                        B = B.parentNode

                    } while (B);

                    return false

                }, hasClass: function(A) {

                    return this.className.match(new RegExp("(\\s|^)nicEdit-" + A + "(\\s|$)"))

                }, addClass: function(A) {

                    if (!this.hasClass(A)) {

                        this.className += " nicEdit-" + A

                    }

                    return this

                }, removeClass: function(A) {

                    if (this.hasClass(A)) {

                        this.className = this.className.replace(new RegExp("(\\s|^)nicEdit-" + A + "(\\s|$)"), " ")

                    }

                    return this

                }, setStyle: function(A) {

                    var B = this.style;

                    for (var C in A) {

                        switch (C) {

                            case"float":

                                B.cssFloat = B.styleFloat = A[C];

                                break;

                            case"opacity":

                                B.opacity = A[C];

                                B.filter = "alpha(opacity=" + Math.round(A[C] * 100) + ")";

                                break;

                            case"className":

                                this.className = A[C];

                                break;

                            default:

                                B[C] = A[C]

                            }

                    }

                    return this

                }, getStyle: function(A, C) {

                    var B = (!C) ? document.defaultView : C;

                    if (this.nodeType == 1) {

                        return(B && B.getComputedStyle) ? B.getComputedStyle(this, null).getPropertyValue(A) : this.currentStyle[bkLib.camelize(A)]

                    }

                }, remove: function() {

                    this.parentNode.removeChild(this);

                    return this

                }, setAttributes: function(A) {

                    for (var B in A) {

                        this[B] = A[B]

                    }

                    return this

                }});

            var bkLib = {isMSIE: (navigator.appVersion.indexOf("MSIE") != -1), addEvent: function(C, B, A) {

                    (C.addEventListener) ? C.addEventListener(B, A, false) : C.attachEvent("on" + B, A)

                }, toArray: function(C) {

                    var B = C.length, A = new Array(B);

                    while (B--) {

                        A[B] = C[B]

                    }

                    return A

                }, noSelect: function(B) {

                    if (B.setAttribute && B.nodeName.toLowerCase() != "input" && B.nodeName.toLowerCase() != "textarea") {

                        B.setAttribute("unselectable", "on")

                    }

                    for (var A = 0; A < B.childNodes.length; A++) {

                        bkLib.noSelect(B.childNodes[A])

                    }

                }, camelize: function(A) {

                    return A.replace(/\-(.)/g, function(B, C) {

                        return C.toUpperCase()

                    })

                }, inArray: function(A, B) {

                    return(bkLib.search(A, B) != null)

                }, search: function(A, C) {

                    for (var B = 0; B < A.length; B++) {

                        if (A[B] == C) {

                            return B

                        }

                    }

                    return null

                }, cancelEvent: function(A) {

                    A = A || window.event;

                    if (A.preventDefault && A.stopPropagation) {

                        A.preventDefault();

                        A.stopPropagation()

                    }

                    return false

                }, domLoad: [], domLoaded: function() {

                    if (arguments.callee.done) {

                        return

                    }

                    arguments.callee.done = true;

                    for (i = 0; i < bkLib.domLoad.length; i++) {

                        bkLib.domLoad[i]()

                    }

                }, onDomLoaded: function(A) {

                    this.domLoad.push(A);

                    if (document.addEventListener) {

                        document.addEventListener("DOMContentLoaded", bkLib.domLoaded, null)

                    } else {

                        if (bkLib.isMSIE) {

                            document.write("<style>.nicEdit-main p { margin: 0; }</style><script id=__ie_onload defer " + ((location.protocol == "https:") ? "src='javascript:void(0)'" : "src=//0") + "><\/script>");

                            $BK("__ie_onload").onreadystatechange = function() {

                                if (this.readyState == "complete") {

                                    bkLib.domLoaded()

                                }

                            }

                        }

                    }

                    window.onload = bkLib.domLoaded

                }};

            function $BK(A) {

                if (typeof (A) == "string") {

                    A = document.getElementById(A)

                }

                return(A && !A.appendTo) ? bkExtend(A, bkElement.prototype) : A

            }

            var bkEvent = {addEvent: function(A, B) {

                    if (B) {

                        this.eventList = this.eventList || {};

                        this.eventList[A] = this.eventList[A] || [];

                        this.eventList[A].push(B)

                    }

                    return this

                }, fireEvent: function() {

                    var A = bkLib.toArray(arguments), C = A.shift();

                    if (this.eventList && this.eventList[C]) {

                        for (var B = 0; B < this.eventList[C].length; B++) {

                            this.eventList[C][B].apply(this, A)

                        }

                    }

                }};

            function __(A) {

                return A

            }

            Function.prototype.closure = function() {

                var A = this, B = bkLib.toArray(arguments), C = B.shift();

                return function() {

                    if (typeof (bkLib) != "undefined") {

                        return A.apply(C, B.concat(bkLib.toArray(arguments)))

                    }

                }

            };

            Function.prototype.closureListener = function() {

                var A = this, C = bkLib.toArray(arguments), B = C.shift();

                return function(E) {

                    E = E || window.event;

                    if (E.target) {

                        var D = E.target

                    } else {

                        var D = E.srcElement

                    }

                    return A.apply(B, [E, D].concat(C))

                }

            };







            var nicEditorConfig = bkClass.extend({

                buttons: {

                    'bold': {name: __('Click to Bold'), command: 'Bold', tags: ['B', 'STRONG'], css: {'font-weight': 'bold'}, key: 'b'},

                    'italic': {name: __('Click to Italic'), command: 'Italic', tags: ['EM', 'I'], css: {'font-style': 'italic'}, key: 'i'},

                    'underline': {name: __('Click to Underline'), command: 'Underline', tags: ['U'], css: {'text-decoration': 'underline'}, key: 'u'},

                    'left': {name: __('Left Align'), command: 'justifyleft', noActive: true},

                    'center': {name: __('Center Align'), command: 'justifycenter', noActive: true},

                    'right': {name: __('Right Align'), command: 'justifyright', noActive: true},

                    'justify': {name: __('Justify Align'), command: 'justifyfull', noActive: true},

                    'ol': {name: __('Insert Ordered List'), command: 'insertorderedlist', tags: ['OL']},

                    'ul': {name: __('Insert Unordered List'), command: 'insertunorderedlist', tags: ['UL']},

                    'subscript': {name: __('Click to Subscript'), command: 'subscript', tags: ['SUB']},

                    'superscript': {name: __('Click to Superscript'), command: 'superscript', tags: ['SUP']},

                    'strikethrough': {name: __('Click to Strike Through'), command: 'strikeThrough', css: {'text-decoration': 'line-through'}},

                    'removeformat': {name: __('Remove Formatting'), command: 'removeformat', noActive: true},

                    'indent': {name: __('Indent Text'), command: 'indent', noActive: true},

                    'outdent': {name: __('Remove Indent'), command: 'outdent', noActive: true},

                    'hr': {name: __('Horizontal Rule'), command: 'insertHorizontalRule', noActive: true}

                },

                iconsPath: 'data:image/gif;base64,R0lGODlh1AESAPcAAAAAABERESIiIjMzMzNmIndVIkR3IkRERFVVVWZmZnd3d90iIu4zM7tEEbtVIqp3M91mAO53EcxmM7t3RIhmd+5ERO5EVe5VVf9VVf9mZv9md+53d/93d1WIIlWIRGaIVXe7RGaIZruIM7uZM/+qM//MM4iIRKqIVYi7RIiqVZm7VbuqVZmZd4i7ZsyZVd2ZVe6ZVcyqRMyZZt2ZZt2qZsyqd92qd8y7d+67ZpnMZt3MVe7MZu7dZv/dZu7MdxEzuxFEuxFVuzNmqjNmuzN3u0R3uyJmzDN3zER3zJl3iP93iGaZmUSZqlWIu2aIqlWIzESI3VWI3VWZ3WaIzGaZzHeZzGaI3WaZ3XeZ3VWq3Waq3Xeq3VWq7maq7neq7ma7/4iIiJmZmZmqiLuqmYiqqqqqqru7u/+IiN2qiMy7iN27iMy7md27me6qiO6qme67mf+7u5nMiLvMmbvdu93MiO7MiN3Mqu7Mqv/Mu+7du8zuu//uqoiZ3YiqzJmqzIiq3Zm73aq73Yiq7oi77pm77qq77rvM3YjM7pnd/6rM7rvM7rvd7szMzMzM3czd3d3d3f/MzO7dzO7d3f/d3f//zO7u3f/u3czd7szd/93d/93u7t3u/+7u7v/u7u7u/+7//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKEALAAAAADUARIAAAj+AEMJHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo0eLhrZQeTJyJMk+oBhWelOjxptKH2PKnEnTIKhDgw7hHLQpY6A/U4oMGUp0aJEpimoqpdgokJ+nUKP6abTUYUqCP4MWLXo06dItnsKKDatJ5NWDldTYUHPnjhoZMvJUnUt3oadCShclunSJp8Y/fEGB+iT2E+FNiqgkqsv4YCBOYyN74uSHcadJBifBgUQQ8CXBhMMa9oRY8VIqnjCp5ntpEahFIjvdoFPwjow3eXqUKJHnzhsZbOgqGK4gQQIECA4cGCCgscxCeGseSpRzy9mLTS5tMTxFLCjSiBX+FXHOcFGhRREZgVFQZmAYBGYK+vH0lEyc+3GWLPFDOSMoQpuA4kUomXhBCEKdcMABZgNNkkEGZzAYSnbbfdJdWN9tEt54Ewni4YeCbLHFFVdIEQUUSBwh0BOpqbaaa5hs0kcae4ww0Epo4EACCSXohgYabU0AE0GMhDGcGWEkEAYnCBFnnHHIJXcARk5CGaVyC5nxpAJNDvfkcchhWVCVVkppUHSMkImcQWpeOaVBiSwyyCWHbKFdF1rkuQVBZIJp5kBFaEfYhYOBZ+cQB3FShhlmlAFGQmFECgYn63EZkSeDDBLdQIUogpcZbSJkJEGcWErQfIDYF0cOrJKxX3/+GSkiSCYAeiEIghwoocSCAjmogRIZwHFVoNt5QuhhmxxKkSCKNKtIItBGSwghHhqxIigxutiaJp5UQsceMdwwkFt5kKAjDiXgoAIIKNzRkkFaPhrKewloVByYyjEnQAABeKQAfI1Bt+lHm0x3ScFbwJZFF11gceBEQ2gXVnejabgJFokgymZ8oZSBQEJpJtCeo0xGNMhdtxJkHnoRJTmmQajax2oOLeSgH6ykmgFGGGA8QinPZpR8kKygCDIgQqAoeAYHGUziK9MVnBUxWMZ6UrGGGGssEbPRJjKth3+IeMUf1obCosWbvGjItzvccFUlMrhxwQvm/ogGCDmAgMb+GxPAm4C8Hr95kJZ+KndAexg9HIqXZS70yJoJ3Vt4vgOw+aSbHD3MuJ8GDaLXtNptokUWUmjxx3UDTb5c5QNNbbHV4G1yCRaBaD0QIyIPZOpBjyNQxu5bH42Ry3zC7Emqq7agfAtLkEFDDS7IJRAokXLyCJJhPHJ9pNdxojPPj/4MRtA2aZAr0w9CfZ3rGsJu8ey1LwuKIt8RMtYlf2hSVhArxq4hJpdwBNtO0ImBvOENG9jABdjSFjSsAAUrsMEbHmAQj4UvOfLCSJiWI4B9Cc4g1OqJm1a3kPdksC7T8sRDNjGIh41wAKybHrS2AK1pbYEQWpDCIqTwh4pMbQr+QKSCEIEIRNoJwSCPOE72QsGIhQROaJCSFKWGEwpCbCETGgFDvQiyxVMdjwysWl4KUlCHPFgiDy4YCKgeAYYDKKk4BwDD7zgWCuplb3vz0h72UFfHDPxKQRy4QNQK8sMgDpGIRkSi9rTHiCYaxDqfKZon/uCJLWwiEYK5Av/M5r8YCXAPOxiBEwhSgzug4QIbsM0EZHAHJrhyBhOsIAJElgA3JqRMhoMhcy4iCEIMwpITqSUdD4JLyu2yIMVc3TEJgimHsLCFe2IICwlxCYFsImxSkMIlEiEFLCBTdTDsIEGmJqJyYuGc6ATEEQ0ChjAlwJEJ4YRyToiQkI1sUpf+EIQnDkYQRRDCKxBpJzJhxglAAGIJYkyBD/JQxjzQwD1gYAQoDmAGRjTqAKBQTxjUqAD1uLGJcJSjAoY5EFBcgAMYwAAHBklI7ZRTROhM5zoJsshFwpMgW6AfJj0BCrBcYRM89cQVgNA/tF3CDDcA5Qgc8QSCsNI3QOrbBN7gSia8IJYF8ZilwDAABECRIgIL67SmNQgPFSREPSnTnxDyCDE1ppmhMMMGV9ccgiTraGp1ayhy0sJQaIcQVshCD7lpBR+69KUxPac6OUocOAoAAJAFAD0Fwh4YNhFTmuIdcn4nkBGRqCCESMSt5ColuiJEoAT5mHyOBwg/mOC1JvD+ASV44AMa0ECFAvmdRw03zzQhbl4RVYBgUiKYR3R0ZweZxElTulIJte6w5kzsYgsCCptK9CBXmF9YfOoJKSCGW1IgKict5ogxjGEEMYiBGTzRVAPKoAYMlMEDbsMCJrBADTWgYFYRYClOdHCjBwmcMjv4W045q1nRKsRYozkQ4Rmzg3UV1QGAZ5C56hLC/SqIhcOJEEGELSJHe7A4FZKILGghCQ5ogAMowMdQiHhf41TES7eQ2HP+YaYDEVoZlvNBUskxFFwdACNOVoiUyfIAX4WTIBbTMorebrL8GWMKTOACF8iWB7R1wZAEksQwlKEMRlJAGMTwgQ94QAwD0W3+G7HU1jj6NjMXyICCNKABDFTAuaEYgowRW+MbHySjjWxxKKIACkoKtbueiIImoPCZTfxgRZrQkCH6YIZImOEEY/gMEQqykhpMwCW+scELXoAGNUzADhW0pUA6OFmJKHisZQ3bjDeCgAGQlDw1uYSJkiCBNuChDb2miJ6tM9xiC4YKfi5IowgigBiO6W+9U04TjYYQecYxJvL0KhMP8AiCzuHbc6jBlbNMBuomMQFHYkQIWiAHPbSgA2gORZe/PCox0zsB3SaIcuUsyApYIAMWYIBzh21sYyMbxwTJqKBDAYUQkahEUTgRilIUhUdzkgsi6kMfnuAELngcFJtGy1T+ZzDqq6Lh0wcJwwFUG4YO5rsguQxnB/mVYYvEXF/74hfIlpmQm8+cXwAwiM9/XvPOiggiQ8950Q2CBR72GgYRiAAMHECQodM86K1TBBZAsbyut+ATB6/gAIQmgFYrxIpYPEhlhYztf/H3pgPhD7jXUIPZZlkSlWGIB+QgB663gADTO/eRFse4R1xn34GMGigYUIEMVEDgWd+615cH9mRL5AgeLufDsxnxiFucCJr4ghNGP/otIAIRXwB5QuDyBgn+5gHBgVdxELAe/r4c1w5JEnK62Bhg0uQShIh4IhqAh+FGoAHCljEowM38OYC9Cgjv2Mq9PCqI5HOfPfFxe4L+DHeCFGILA+PIY8JC9zXoIMuVwJlCDNB3wcgB8Ezf+hUAahBIxNnOV1m8vxnAGYEQvPng9nzR5xBGUIBBcIBAkIBA8AMM2IACAXpfEIESOIGqhxCV8AA/Il9CohFlgHNKB2AXQVcYtnQ2J3NKF1lCZ4I5lxDJ0jH6AnSQlYIeqHMK0XlRYAUOAHVRBwHIZxAjGAAoGHl+N3kWAn0e4VlXYDk9s0Hd11m/5IInGIMHMYJBSBBN8RQiYAkuIAJbCBVUwRAGoDx+B38EgQVXkAl8cAlXEH4EAQkWwFLTswD8F2OSN3lfNwVGqBQsoj98OBaC0V4IwQYP8GlbhnuGOBOhIqI4SwFsO9gAbUARRQAtBVdsVVAFHHKIBfF9bOgRBVAHdSACIiAJESEGHcBu7xZvA8EHV1BNV+AJmbB1CQEJfAQK/QcokjiJglGJl0gThkAFRPCLwBiMT2AImFiMxriIKeYAj0gRf4AFQjEUQhCN0iiNTXCMdVEABeACNFCIDyEGBEAABoCKNdGMzzgE03iO1WiN6riO7NiO7viO8CgRAQEAOw==',

                buttonList: ['save', 'bold', 'italic', 'underline', 'left', 'center', 'right', 'justify', 'ol', 'ul', 'fontSize', 'fontFamily', 'fontFormat', 'indent', 'outdent', 'image', 'upload', 'link', 'unlink', 'forecolor', 'bgcolor'],

                iconList: {"xhtml": 1, "bgcolor": 2, "forecolor": 3, "bold": 4, "center": 5, "hr": 6, "indent": 7, "italic": 8, "justify": 9, "left": 10, "ol": 11, "outdent": 12, "removeformat": 13, "right": 14, "save": 25, "strikethrough": 16, "subscript": 17, "superscript": 18, "ul": 19, "underline": 20, "image": 21, "link": 22, "unlink": 23, "close": 24, "arrow": 26}



            });

            ;

            var nicEditors = {nicPlugins: [], editors: [], registerPlugin: function(B, A) {

                    this.nicPlugins.push({p: B, o: A})

                }, allTextAreas: function(C) {

                    var A = document.getElementsByTagName("textarea");

                    for (var B = 0; B < A.length; B++) {

                        nicEditors.editors.push(new nicEditor(C).panelInstance(A[B]))

                    }

                    return nicEditors.editors

                }, findEditor: function(C) {

                    var B = nicEditors.editors;

                    for (var A = 0; A < B.length; A++) {

                        if (B[A].instanceById(C)) {

                            return B[A].instanceById(C)

                        }

                    }

                }};

            var nicEditor = bkClass.extend({construct: function(C) {

                    this.options = new nicEditorConfig();

                    bkExtend(this.options, C);

                    this.nicInstances = new Array();

                    this.loadedPlugins = new Array();

                    var A = nicEditors.nicPlugins;

                    for (var B = 0; B < A.length; B++) {

                        this.loadedPlugins.push(new A[B].p(this, A[B].o))

                    }

                    nicEditors.editors.push(this);

                    bkLib.addEvent(document.body, "mousedown", this.selectCheck.closureListener(this))

                }, panelInstance: function(B, C) {

                    B = this.checkReplace($BK(B));

                    var A = new bkElement("DIV").setStyle({width: (parseInt(B.getStyle("width")) || B.clientWidth) + "px"}).appendBefore(B);

                    this.setPanel(A);

                    return this.addInstance(B, C)

                }, checkReplace: function(B) {

                    var A = nicEditors.findEditor(B);

                    if (A) {

                        A.removeInstance(B);

                        A.removePanel()

                    }

                    return B

                }, addInstance: function(B, C) {

                    B = this.checkReplace($BK(B));

                    if (B.contentEditable || !!window.opera) {

                        var A = new nicEditorInstance(B, C, this)

                    } else {

                        var A = new nicEditorIFrameInstance(B, C, this)

                    }

                    this.nicInstances.push(A);

                    return this

                }, removeInstance: function(C) {

                    C = $BK(C);

                    var B = this.nicInstances;

                    for (var A = 0; A < B.length; A++) {

                        if (B[A].e == C) {

                            B[A].remove();

                            this.nicInstances.splice(A, 1)

                        }

                    }

                }, removePanel: function(A) {

                    if (this.nicPanel) {

                        this.nicPanel.remove();

                        this.nicPanel = null

                    }

                }, instanceById: function(C) {

                    C = $BK(C);

                    var B = this.nicInstances;

                    for (var A = 0; A < B.length; A++) {

                        if (B[A].e == C) {

                            return B[A]

                        }

                    }

                }, setPanel: function(A) {

                    this.nicPanel = new nicEditorPanel($BK(A), this.options, this);

                    this.fireEvent("panel", this.nicPanel);

                    return this

                }, nicCommand: function(B, A) {

                    if (this.selectedInstance) {

                        this.selectedInstance.nicCommand(B, A)

                    }

                }, getIcon: function(D, A) {

                    var C = this.options.iconList[D];

                    var B = (A.iconFiles) ? A.iconFiles[D] : "";

                    return{backgroundImage: "url('" + ((C) ? this.options.iconsPath : B) + "')", backgroundPosition: ((C) ? ((C - 1) * -18) : 0) + "px 0px"}

                }, selectCheck: function(C, A) {

                    var B = false;

                    do {

                        if (A.className && A.className.indexOf("nicEdit") != -1) {

                            return false

                        }

                    } while (A = A.parentNode);

                    this.fireEvent("blur", this.selectedInstance, A);

                    this.lastSelectedInstance = this.selectedInstance;

                    this.selectedInstance = null;

                    return false

                }});

            nicEditor = nicEditor.extend(bkEvent);

            var nicEditorInstance = bkClass.extend({isSelected: false, construct: function(G, D, C) {

                    this.ne = C;

                    this.elm = this.e = G;

                    this.options = D || {};

                    newX = parseInt(G.getStyle("width")) || G.clientWidth;

                    newY = parseInt(G.getStyle("height")) || G.clientHeight;

                    this.initialHeight = newY - 8;

                    var H = (G.nodeName.toLowerCase() == "textarea");

                    if (H || this.options.hasPanel) {

                        var B = (bkLib.isMSIE && !((typeof document.body.style.maxHeight != "undefined") && document.compatMode == "CSS1Compat"));

                        var E = {width: newX + "px", border: "1px solid #ccc", borderTop: 0, overflowY: "auto", overflowX: "hidden"};

                        E[(B) ? "height" : "maxHeight"] = (this.ne.options.maxHeight) ? this.ne.options.maxHeight + "px" : null;

                        this.editorContain = new bkElement("DIV").setStyle(E).appendBefore(G);

                        var A = new bkElement("DIV").setStyle({width: (newX - 8) + "px", margin: "4px", minHeight: newY + "px"}).addClass("main").appendTo(this.editorContain);

                        G.setStyle({display: "none"});

                        A.innerHTML = G.innerHTML;

                        if (H) {

                            A.setContent(G.value);

                            this.copyElm = G;

                            var F = G.parentTag("FORM");

                            if (F) {

                                bkLib.addEvent(F, "submit", this.saveContent.closure(this))

                            }

                        }

                        A.setStyle((B) ? {height: newY + "px"} : {overflow: "hidden"});

                        this.elm = A

                    }

                    this.ne.addEvent("blur", this.blur.closure(this));

                    this.init();

                    this.blur()

                }, init: function() {

                    this.elm.setAttribute("contentEditable", "true");

                    if (this.getContent() == "") {

                        this.setContent("<br />")

                    }

                    this.instanceDoc = document.defaultView;

                    this.elm.addEvent("mousedown", this.selected.closureListener(this)).addEvent("keypress", this.keyDown.closureListener(this)).addEvent("focus", this.selected.closure(this)).addEvent("blur", this.blur.closure(this)).addEvent("keyup", this.selected.closure(this));

                    this.ne.fireEvent("add", this)

                }, remove: function() {

                    this.saveContent();

                    if (this.copyElm || this.options.hasPanel) {

                        this.editorContain.remove();

                        this.e.setStyle({display: "block"});

                        this.ne.removePanel()

                    }

                    this.disable();

                    this.ne.fireEvent("remove", this)

                }, disable: function() {

                    this.elm.setAttribute("contentEditable", "false")

                }, getSel: function() {

                    return(window.getSelection) ? window.getSelection() : document.selection

                }, getRng: function() {

                    var A = this.getSel();

                    if (!A || A.rangeCount === 0) {

                        return

                    }

                    return(A.rangeCount > 0) ? A.getRangeAt(0) : A.createRange()

                }, selRng: function(A, B) {

                    if (window.getSelection) {

                        B.removeAllRanges();

                        B.addRange(A)

                    } else {

                        A.select()

                    }

                }, selElm: function() {

                    var C = this.getRng();

                    if (!C) {

                        return

                    }

                    if (C.startContainer) {

                        var D = C.startContainer;

                        if (C.cloneContents().childNodes.length == 1) {

                            for (var B = 0; B < D.childNodes.length; B++) {

                                var A = D.childNodes[B].ownerDocument.createRange();

                                A.selectNode(D.childNodes[B]);

                                if (C.compareBoundaryPoints(Range.START_TO_START, A) != 1 && C.compareBoundaryPoints(Range.END_TO_END, A) != -1) {

                                    return $BK(D.childNodes[B])

                                }

                            }

                        }

                        return $BK(D)

                    } else {

                        return $BK((this.getSel().type == "Control") ? C.item(0) : C.parentElement())

                    }

                }, saveRng: function() {

                    this.savedRange = this.getRng();

                    this.savedSel = this.getSel()

                }, restoreRng: function() {

                    if (this.savedRange) {

                        this.selRng(this.savedRange, this.savedSel)

                    }

                }, keyDown: function(B, A) {

                    if (B.ctrlKey) {

                        this.ne.fireEvent("key", this, B)

                    }

                }, selected: function(C, A) {

                    if (!A && !(A = this.selElm)) {

                        A = this.selElm()

                    }

                    if (!C.ctrlKey) {

                        var B = this.ne.selectedInstance;

                        if (B != this) {

                            if (B) {

                                this.ne.fireEvent("blur", B, A)

                            }

                            this.ne.selectedInstance = this;

                            this.ne.fireEvent("focus", B, A)

                        }

                        this.ne.fireEvent("selected", B, A);

                        this.isFocused = true;

                        this.elm.addClass("selected")

                    }

                    return false

                }, blur: function() {

                    this.isFocused = false;

                    this.elm.removeClass("selected")

                }, saveContent: function() {

                    if (this.copyElm || this.options.hasPanel) {

                        this.ne.fireEvent("save", this);

                        (this.copyElm) ? this.copyElm.value = this.getContent() : this.e.innerHTML = this.getContent()

                    }

                }, getElm: function() {

                    return this.elm

                }, getContent: function() {

                    this.content = this.getElm().innerHTML;

                    this.ne.fireEvent("get", this);

                    return this.content

                }, setContent: function(A) {

                    this.content = A;

                    this.ne.fireEvent("set", this);

                    this.elm.innerHTML = this.content

                }, nicCommand: function(B, A) {

                    document.execCommand(B, false, A)

                }});

            var nicEditorIFrameInstance = nicEditorInstance.extend({savedStyles: [], init: function() {

                    var B = this.elm.innerHTML.replace(/^\s+|\s+$/g, "");

                    this.elm.innerHTML = "";

                    (!B) ? B = "<br />" : B;

                    this.initialContent = B;

                    this.elmFrame = new bkElement("iframe").setAttributes({src: "javascript:;", frameBorder: 0, allowTransparency: "true", scrolling: "no"}).setStyle({height: "100px", width: "100%"}).addClass("frame").appendTo(this.elm);

                    if (this.copyElm) {

                        this.elmFrame.setStyle({width: (this.elm.offsetWidth - 4) + "px"})

                    }

                    var A = ["font-size", "font-family", "font-weight", "color"];

                    for (itm in A) {

                        this.savedStyles[bkLib.camelize(itm)] = this.elm.getStyle(itm)

                    }

                    setTimeout(this.initFrame.closure(this), 50)

                }, disable: function() {

                    this.elm.innerHTML = this.getContent()

                }, initFrame: function() {

                    var B = $BK(this.elmFrame.contentWindow.document);

                    B.designMode = "on";

                    B.open();

                    var A = this.ne.options.externalCSS;

                    B.write("<html><head>" + ((A) ? '<link href="' + A + '" rel="stylesheet" type="text/css" />' : "") + '</head><body id="nicEditContent" style="margin: 0 !important; background-color: transparent !important;">' + this.initialContent + "</body></html>");

                    B.close();

                    this.frameDoc = B;

                    this.frameWin = $BK(this.elmFrame.contentWindow);

                    this.frameContent = $BK(this.frameWin.document.body).setStyle(this.savedStyles);

                    this.instanceDoc = this.frameWin.document.defaultView;

                    this.heightUpdate();

                    this.frameDoc.addEvent("mousedown", this.selected.closureListener(this)).addEvent("keyup", this.heightUpdate.closureListener(this)).addEvent("keydown", this.keyDown.closureListener(this)).addEvent("keyup", this.selected.closure(this));

                    this.ne.fireEvent("add", this)

                }, getElm: function() {

                    return this.frameContent

                }, setContent: function(A) {

                    this.content = A;

                    this.ne.fireEvent("set", this);

                    this.frameContent.innerHTML = this.content;

                    this.heightUpdate()

                }, getSel: function() {

                    return(this.frameWin) ? this.frameWin.getSelection() : this.frameDoc.selection

                }, heightUpdate: function() {

                    this.elmFrame.style.height = Math.max(this.frameContent.offsetHeight, this.initialHeight) + "px"

                }, nicCommand: function(B, A) {

                    this.frameDoc.execCommand(B, false, A);

                    setTimeout(this.heightUpdate.closure(this), 100)

                }});

            var nicEditorPanel = bkClass.extend({construct: function(E, B, A) {

                    this.elm = E;

                    this.options = B;

                    this.ne = A;

                    this.panelButtons = new Array();

                    this.buttonList = bkExtend([], this.ne.options.buttonList);

                    this.panelContain = new bkElement("DIV").setStyle({overflow: "hidden", width: "100%", border: "1px solid #cccccc", backgroundColor: "#efefef"}).addClass("panelContain");

                    this.panelElm = new bkElement("DIV").setStyle({margin: "2px", marginTop: "0px", zoom: 1, overflow: "hidden"}).addClass("panel").appendTo(this.panelContain);

                    this.panelContain.appendTo(E);

                    var C = this.ne.options;

                    var D = C.buttons;

                    for (button in D) {

                        this.addButton(button, C, true)

                    }

                    this.reorder();

                    E.noSelect()

                }, addButton: function(buttonName, options, noOrder) {

                    var button = options.buttons[buttonName];

                    var type = (button.type) ? eval("(typeof(" + button.type + ') == "undefined") ? null : ' + button.type + ";") : nicEditorButton;

                    var hasButton = bkLib.inArray(this.buttonList, buttonName);

                    if (type && (hasButton || this.ne.options.fullPanel)) {

                        this.panelButtons.push(new type(this.panelElm, buttonName, options, this.ne));

                        if (!hasButton) {

                            this.buttonList.push(buttonName)

                        }

                    }

                }, findButton: function(B) {

                    for (var A = 0; A < this.panelButtons.length; A++) {

                        if (this.panelButtons[A].name == B) {

                            return this.panelButtons[A]

                        }

                    }

                }, reorder: function() {

                    var C = this.buttonList;

                    for (var B = 0; B < C.length; B++) {

                        var A = this.findButton(C[B]);

                        if (A) {

                            this.panelElm.appendChild(A.margin)

                        }

                    }

                }, remove: function() {

                    this.elm.remove()

                }});

            var nicEditorButton = bkClass.extend({construct: function(D, A, C, B) {

                    this.options = C.buttons[A];

                    this.name = A;

                    this.ne = B;

                    this.elm = D;

                    this.margin = new bkElement("DIV").setStyle({"float": "left", marginTop: "2px"}).appendTo(D);

                    this.contain = new bkElement("DIV").setStyle({width: "20px", height: "20px"}).addClass("buttonContain").appendTo(this.margin);

                    this.border = new bkElement("DIV").setStyle({backgroundColor: "#efefef", border: "1px solid #efefef"}).appendTo(this.contain);

                    this.button = new bkElement("DIV").setStyle({width: "18px", height: "18px", overflow: "hidden", zoom: 1, cursor: "pointer"}).addClass("button").setStyle(this.ne.getIcon(A, C)).appendTo(this.border);

                    this.button.addEvent("mouseover", this.hoverOn.closure(this)).addEvent("mouseout", this.hoverOff.closure(this)).addEvent("mousedown", this.mouseClick.closure(this)).noSelect();

                    if (!window.opera) {

                        this.button.onmousedown = this.button.onclick = bkLib.cancelEvent

                    }

                    B.addEvent("selected", this.enable.closure(this)).addEvent("blur", this.disable.closure(this)).addEvent("key", this.key.closure(this));

                    this.disable();

                    this.init()

                }, init: function() {

                }, hide: function() {

                    this.contain.setStyle({display: "none"})

                }, updateState: function() {

                    if (this.isDisabled) {

                        this.setBg()

                    } else {

                        if (this.isHover) {

                            this.setBg("hover")

                        } else {

                            if (this.isActive) {

                                this.setBg("active")

                            } else {

                                this.setBg()

                            }

                        }

                    }

                }, setBg: function(A) {

                    switch (A) {

                        case"hover":

                            var B = {border: "1px solid #666", backgroundColor: "#ddd"};

                            break;

                        case"active":

                            var B = {border: "1px solid #666", backgroundColor: "#ccc"};

                            break;

                        default:

                            var B = {border: "1px solid #efefef", backgroundColor: "#efefef"}

                    }

                    this.border.setStyle(B).addClass("button-" + A)

                }, checkNodes: function(A) {

                    var B = A;

                    do {

                        if (this.options.tags && bkLib.inArray(this.options.tags, B.nodeName)) {

                            this.activate();

                            return true

                        }

                    } while (B = B.parentNode && B.className != "nicEdit");

                    B = $BK(A);

                    while (B.nodeType == 3) {

                        B = $BK(B.parentNode)

                    }

                    if (this.options.css) {

                        for (itm in this.options.css) {

                            if (B.getStyle(itm, this.ne.selectedInstance.instanceDoc) == this.options.css[itm]) {

                                this.activate();

                                return true

                            }

                        }

                    }

                    this.deactivate();

                    return false

                }, activate: function() {

                    if (!this.isDisabled) {

                        this.isActive = true;

                        this.updateState();

                        this.ne.fireEvent("buttonActivate", this)

                    }

                }, deactivate: function() {

                    this.isActive = false;

                    this.updateState();

                    if (!this.isDisabled) {

                        this.ne.fireEvent("buttonDeactivate", this)

                    }

                }, enable: function(A, B) {

                    this.isDisabled = false;

                    this.contain.setStyle({opacity: 1}).addClass("buttonEnabled");

                    this.updateState();

                    this.checkNodes(B)

                }, disable: function(A, B) {

                    this.isDisabled = true;

                    this.contain.setStyle({opacity: 0.6}).removeClass("buttonEnabled");

                    this.updateState()

                }, toggleActive: function() {

                    (this.isActive) ? this.deactivate() : this.activate()

                }, hoverOn: function() {

                    if (!this.isDisabled) {

                        this.isHover = true;

                        this.updateState();

                        this.ne.fireEvent("buttonOver", this)

                    }

                }, hoverOff: function() {

                    this.isHover = false;

                    this.updateState();

                    this.ne.fireEvent("buttonOut", this)

                }, mouseClick: function() {

                    if (this.options.command) {

                        this.ne.nicCommand(this.options.command, this.options.commandArgs);

                        if (!this.options.noActive) {

                            this.toggleActive()

                        }

                    }

                    this.ne.fireEvent("buttonClick", this)

                }, key: function(A, B) {

                    if (this.options.key && B.ctrlKey && String.fromCharCode(B.keyCode || B.charCode).toLowerCase() == this.options.key) {

                        this.mouseClick();

                        if (B.preventDefault) {

                            B.preventDefault()

                        }

                    }

                }});

            var nicPlugin = bkClass.extend({construct: function(B, A) {

                    this.options = A;

                    this.ne = B;

                    this.ne.addEvent("panel", this.loadPanel.closure(this));

                    this.init()

                }, loadPanel: function(C) {

                    var B = this.options.buttons;

                    for (var A in B) {

                        C.addButton(A, this.options)

                    }

                    C.reorder()

                }, init: function() {

                }});





            var nicPaneOptions = {};



            var nicEditorPane = bkClass.extend({construct: function(D, C, B, A) {

                    this.ne = C;

                    this.elm = D;

                    this.pos = D.pos();

                    this.contain = new bkElement("div").setStyle({zIndex: "99999", overflow: "hidden", position: "absolute", left: this.pos[0] + "px", top: this.pos[1] + "px"});

                    this.pane = new bkElement("div").setStyle({fontSize: "12px", border: "1px solid #ccc", overflow: "hidden", padding: "4px", textAlign: "left", backgroundColor: "#ffffc9"}).addClass("pane").setStyle(B).appendTo(this.contain);

                    if (A && !A.options.noClose) {

                        this.close = new bkElement("div").setStyle({"float": "right", height: "16px", width: "16px", cursor: "pointer"}).setStyle(this.ne.getIcon("close", nicPaneOptions)).addEvent("mousedown", A.removePane.closure(this)).appendTo(this.pane)

                    }

                    this.contain.noSelect().appendTo(document.body);

                    this.position();

                    this.init()

                }, init: function() {

                }, position: function() {

                    if (this.ne.nicPanel) {

                        var B = this.ne.nicPanel.elm;

                        var A = B.pos();

                        var C = A[0] + parseInt(B.getStyle("width")) - (parseInt(this.pane.getStyle("width")) + 8);

                        if (C < this.pos[0]) {

                            this.contain.setStyle({left: C + "px"})

                        }

                    }

                }, toggle: function() {

                    this.isVisible = !this.isVisible;

                    this.contain.setStyle({display: ((this.isVisible) ? "block" : "none")})

                }, remove: function() {

                    if (this.contain) {

                        this.contain.remove();

                        this.contain = null

                    }

                }, append: function(A) {

                    A.appendTo(this.pane)

                }, setContent: function(A) {

                    this.pane.setContent(A)

                }});



            var nicEditorAdvancedButton = nicEditorButton.extend({init: function() {

                    this.ne.addEvent("selected", this.removePane.closure(this)).addEvent("blur", this.removePane.closure(this))

                }, mouseClick: function() {

                    if (!this.isDisabled) {

                        if (this.pane && this.pane.pane) {

                            this.removePane()

                        } else {

                            this.pane = new nicEditorPane(this.contain, this.ne, {width: (this.width || "270px"), backgroundColor: "#fff"}, this);

                            this.addPane();

                            this.ne.selectedInstance.saveRng()

                        }

                    }

                }, addForm: function(C, G) {

                    this.form = new bkElement("form").addEvent("submit", this.submit.closureListener(this));

                    this.pane.append(this.form);

                    this.inputs = {};

                    for (itm in C) {

                        var D = C[itm];

                        var F = "";

                        if (G) {

                            F = G.getAttribute(itm)

                        }

                        if (!F) {

                            F = D.value || ""

                        }

                        var A = C[itm].type;

                        if (A == "title") {

                            new bkElement("div").setContent(D.txt).setStyle({fontSize: "14px", fontWeight: "bold", padding: "0px", margin: "2px 0"}).appendTo(this.form)

                        } else {

                            var B = new bkElement("div").setStyle({overflow: "hidden", clear: "both"}).appendTo(this.form);

                            if (D.txt) {

                                new bkElement("label").setAttributes({"for": itm}).setContent(D.txt).setStyle({margin: "2px 4px", fontSize: "13px", width: "50px", lineHeight: "20px", textAlign: "right", "float": "left"}).appendTo(B)

                            }

                            switch (A) {

                                case"text":

                                    this.inputs[itm] = new bkElement("input").setAttributes({id: itm, value: F, type: "text"}).setStyle({margin: "2px 0", fontSize: "13px", "float": "left", height: "20px", border: "1px solid #ccc", overflow: "hidden"}).setStyle(D.style).appendTo(B);

                                    break;

                                case"select":

                                    this.inputs[itm] = new bkElement("select").setAttributes({id: itm}).setStyle({border: "1px solid #ccc", "float": "left", margin: "2px 0"}).appendTo(B);

                                    for (opt in D.options) {

                                        var E = new bkElement("option").setAttributes({value: opt, selected: (opt == F) ? "selected" : ""}).setContent(D.options[opt]).appendTo(this.inputs[itm])

                                    }

                                    break;

                                case"content":

                                    this.inputs[itm] = new bkElement("textarea").setAttributes({id: itm}).setStyle({border: "1px solid #ccc", "float": "left"}).setStyle(D.style).appendTo(B);

                                    this.inputs[itm].value = F

                                }

                        }

                    }

                    new bkElement("input").setAttributes({type: "submit"}).setStyle({backgroundColor: "#efefef", border: "1px solid #ccc", margin: "3px 0", "float": "left", clear: "both"}).appendTo(this.form);

                    this.form.onsubmit = bkLib.cancelEvent

                }, submit: function() {

                }, findElm: function(B, A, E) {

                    var D = this.ne.selectedInstance.getElm().getElementsByTagName(B);

                    for (var C = 0; C < D.length; C++) {

                        if (D[C].getAttribute(A) == E) {

                            return $BK(D[C])

                        }

                    }

                }, removePane: function() {

                    if (this.pane) {

                        this.pane.remove();

                        this.pane = null;

                        this.ne.selectedInstance.restoreRng()

                    }

                }});



            var nicButtonTips = bkClass.extend({construct: function(A) {

                    this.ne = A;

                    A.addEvent("buttonOver", this.show.closure(this)).addEvent("buttonOut", this.hide.closure(this))

                }, show: function(A) {

                    this.timer = setTimeout(this.create.closure(this, A), 400)

                }, create: function(A) {

                    this.timer = null;

                    if (!this.pane) {

                        this.pane = new nicEditorPane(A.button, this.ne, {fontSize: "12px", marginTop: "5px"});

                        this.pane.setContent(A.options.name)

                    }

                }, hide: function(A) {

                    if (this.timer) {

                        clearTimeout(this.timer)

                    }

                    if (this.pane) {

                        this.pane = this.pane.remove()

                    }

                }});

            nicEditors.registerPlugin(nicButtonTips);





            var nicSelectOptions = {

                buttons: {

                    'fontSize': {name: __('Select Font Size'), type: 'nicEditorFontSizeSelect', command: 'fontsize'},

                    'fontFamily': {name: __('Select Font Family'), type: 'nicEditorFontFamilySelect', command: 'fontname'},

                    'fontFormat': {name: __('Select Font Format'), type: 'nicEditorFontFormatSelect', command: 'formatBlock'}

                }

            };



            var nicEditorSelect = bkClass.extend({construct: function(D, A, C, B) {

                    this.options = C.buttons[A];

                    this.elm = D;

                    this.ne = B;

                    this.name = A;

                    this.selOptions = new Array();

                    this.margin = new bkElement("div").setStyle({"float": "left", margin: "2px 1px 0 1px"}).appendTo(this.elm);

                    this.contain = new bkElement("div").setStyle({width: "90px", height: "20px", cursor: "pointer", overflow: "hidden"}).addClass("selectContain").addEvent("click", this.toggle.closure(this)).appendTo(this.margin);

                    this.items = new bkElement("div").setStyle({overflow: "hidden", zoom: 1, border: "1px solid #ccc", paddingLeft: "3px", backgroundColor: "#fff"}).appendTo(this.contain);

                    this.control = new bkElement("div").setStyle({overflow: "hidden", "float": "right", height: "18px", width: "16px"}).addClass("selectControl").setStyle(this.ne.getIcon("arrow", C)).appendTo(this.items);

                    this.txt = new bkElement("div").setStyle({overflow: "hidden", "float": "left", width: "66px", height: "14px", marginTop: "1px", fontFamily: "sans-serif", textAlign: "center", fontSize: "12px"}).addClass("selectTxt").appendTo(this.items);

                    if (!window.opera) {

                        this.contain.onmousedown = this.control.onmousedown = this.txt.onmousedown = bkLib.cancelEvent

                    }

                    this.margin.noSelect();

                    this.ne.addEvent("selected", this.enable.closure(this)).addEvent("blur", this.disable.closure(this));

                    this.disable();

                    this.init()

                }, disable: function() {

                    this.isDisabled = true;

                    this.close();

                    this.contain.setStyle({opacity: 0.6})

                }, enable: function(A) {

                    this.isDisabled = false;

                    this.close();

                    this.contain.setStyle({opacity: 1})

                }, setDisplay: function(A) {

                    this.txt.setContent(A)

                }, toggle: function() {

                    if (!this.isDisabled) {

                        (this.pane) ? this.close() : this.open()

                    }

                }, open: function() {

                    this.pane = new nicEditorPane(this.items, this.ne, {width: "88px", padding: "0px", borderTop: 0, borderLeft: "1px solid #ccc", borderRight: "1px solid #ccc", borderBottom: "0px", backgroundColor: "#fff"});

                    for (var C = 0; C < this.selOptions.length; C++) {

                        var B = this.selOptions[C];

                        var A = new bkElement("div").setStyle({overflow: "hidden", borderBottom: "1px solid #ccc", width: "88px", textAlign: "left", overflow:"hidden", cursor: "pointer"});

                        var D = new bkElement("div").setStyle({padding: "0px 4px"}).setContent(B[1]).appendTo(A).noSelect();

                        D.addEvent("click", this.update.closure(this, B[0])).addEvent("mouseover", this.over.closure(this, D)).addEvent("mouseout", this.out.closure(this, D)).setAttributes("id", B[0]);

                        this.pane.append(A);

                        if (!window.opera) {

                            D.onmousedown = bkLib.cancelEvent

                        }

                    }

                }, close: function() {

                    if (this.pane) {

                        this.pane = this.pane.remove()

                    }

                }, over: function(A) {

                    A.setStyle({backgroundColor: "#ccc"})

                }, out: function(A) {

                    A.setStyle({backgroundColor: "#fff"})

                }, add: function(B, A) {

                    this.selOptions.push(new Array(B, A))

                }, update: function(A) {

                    this.ne.nicCommand(this.options.command, A);

                    this.close()

                }});

            var nicEditorFontSizeSelect = nicEditorSelect.extend({sel: {1: "1&nbsp;(8pt)", 2: "2&nbsp;(10pt)", 3: "3&nbsp;(12pt)", 4: "4&nbsp;(14pt)", 5: "5&nbsp;(18pt)", 6: "6&nbsp;(24pt)"}, init: function() {

                    this.setDisplay("Font&nbsp;Size...");

                    for (itm in this.sel) {

                        this.add(itm, '<font size="' + itm + '">' + this.sel[itm] + "</font>")

                    }

                }});

            var nicEditorFontFamilySelect = nicEditorSelect.extend({sel: {arial: "Arial", "comic sans ms": "Comic Sans", "courier new": "Courier New", georgia: "Georgia", helvetica: "Helvetica", impact: "Impact", "times new roman": "Times", "trebuchet ms": "Trebuchet", verdana: "Verdana"}, init: function() {

                    this.setDisplay("Font&nbsp;Family...");

                    for (itm in this.sel) {

                        this.add(itm, '<font face="' + itm + '">' + this.sel[itm] + "</font>")

                    }

                }});

            var nicEditorFontFormatSelect = nicEditorSelect.extend({sel: {p: "Paragraph", pre: "Pre", h6: "Heading&nbsp;6", h5: "Heading&nbsp;5", h4: "Heading&nbsp;4", h3: "Heading&nbsp;3", h2: "Heading&nbsp;2", h1: "Heading&nbsp;1"}, init: function() {

                    this.setDisplay("Font&nbsp;Format...");

                    for (itm in this.sel) {

                        var A = itm.toUpperCase();

                        this.add("<" + A + ">", "<" + itm + ' style="padding: 0px; margin: 0px;">' + this.sel[itm] + "</" + A + ">")

                    }

                }});

            nicEditors.registerPlugin(nicPlugin, nicSelectOptions);





            var nicLinkOptions = {

                buttons: {

                    'link': {name: 'Add Link', type: 'nicLinkButton', tags: ['A']},

                    'unlink': {name: 'Remove Link', command: 'unlink', noActive: true}

                }

            };



            var nicLinkButton = nicEditorAdvancedButton.extend({addPane: function() {

                    this.ln = this.ne.selectedInstance.selElm().parentTag("A");

                    this.addForm({"": {type: "title", txt: "Add/Edit Link"}, href: {type: "text", txt: "URL", value: "http://", style: {width: "150px"}}, title: {type: "text", txt: "Title"}, target: {type: "select", txt: "Open In", options: {"": "Current Window", _blank: "New Window"}, style: {width: "100px"}}}, this.ln)

                }, submit: function(C) {

                    var A = this.inputs.href.value;

                    if (A == "http://" || A == "") {

                        alert("You must enter a URL to Create a Link");

                        return false

                    }

                    this.removePane();

                    if (!this.ln) {

                        var B = "javascript:nicTemp();";

                        this.ne.nicCommand("createlink", B);

                        this.ln = this.findElm("A", "href", B)

                    }

                    if (this.ln) {

                        this.ln.setAttributes({href: this.inputs.href.value, title: this.inputs.title.value, target: this.inputs.target.options[this.inputs.target.selectedIndex].value})

                    }

                }});

            nicEditors.registerPlugin(nicPlugin, nicLinkOptions);





            var nicColorOptions = {

                buttons: {

                    'forecolor': {name: __('Change Text Color'), type: 'nicEditorColorButton', noClose: true},

                    'bgcolor': {name: __('Change Background Color'), type: 'nicEditorBgColorButton', noClose: true}

                }

            };



            var nicEditorColorButton = nicEditorAdvancedButton.extend({addPane: function() {

                    var D = {0: "00", 1: "33", 2: "66", 3: "99", 4: "CC", 5: "FF"};

                    var H = new bkElement("DIV").setStyle({width: "270px"});

                    for (var A in D) {

                        for (var F in D) {

                            for (var E in D) {

                                var I = "#" + D[A] + D[E] + D[F];

                                var C = new bkElement("DIV").setStyle({cursor: "pointer", height: "15px", "float": "left"}).appendTo(H);

                                var G = new bkElement("DIV").setStyle({border: "2px solid " + I}).appendTo(C);

                                var B = new bkElement("DIV").setStyle({backgroundColor: I, overflow: "hidden", width: "11px", height: "11px"}).addEvent("click", this.colorSelect.closure(this, I)).addEvent("mouseover", this.on.closure(this, G)).addEvent("mouseout", this.off.closure(this, G, I)).appendTo(G);

                                if (!window.opera) {

                                    C.onmousedown = B.onmousedown = bkLib.cancelEvent

                                }

                            }

                        }

                    }

                    this.pane.append(H.noSelect())

                }, colorSelect: function(A) {

                    this.ne.nicCommand("foreColor", A);

                    this.removePane()

                }, on: function(A) {

                    A.setStyle({border: "2px solid #000"})

                }, off: function(A, B) {

                    A.setStyle({border: "2px solid " + B})

                }});

            var nicEditorBgColorButton = nicEditorColorButton.extend({colorSelect: function(A) {

                    this.ne.nicCommand("hiliteColor", A);

                    this.removePane()

                }});

            nicEditors.registerPlugin(nicPlugin, nicColorOptions);





            var nicImageOptions = {

                buttons: {

                    'image': {name: 'Add Image', type: 'nicImageButton', tags: ['IMG']}

                }



            };



            var nicImageButton = nicEditorAdvancedButton.extend({addPane: function() {

                    this.im = this.ne.selectedInstance.selElm().parentTag("IMG");

                    this.addForm({"": {type: "title", txt: "Add/Edit Image"}, src: {type: "text", txt: "URL", value: "http://", style: {width: "150px"}}, alt: {type: "text", txt: "Alt Text", style: {width: "100px"}}, align: {type: "select", txt: "Align", options: {none: "Default", left: "Left", right: "Right"}}}, this.im)

                }, submit: function(B) {

                    var C = this.inputs.src.value;

                    if (C == "" || C == "http://") {

                        alert("You must enter a Image URL to insert");

                        return false

                    }

                    this.removePane();

                    if (!this.im) {

                        var A = "javascript:nicImTemp();";

                        this.ne.nicCommand("insertImage", A);

                        this.im = this.findElm("IMG", "src", A)

                    }

                    if (this.im) {

                        this.im.setAttributes({src: this.inputs.src.value, alt: this.inputs.alt.value, align: this.inputs.align.value})

                    }

                }});

            nicEditors.registerPlugin(nicPlugin, nicImageOptions);





            var nicSaveOptions = {

                buttons: {

                    'save': {name: __('Save this content'), type: 'nicEditorSaveButton'}

                }

            };



            var nicEditorSaveButton = nicEditorButton.extend({init: function() {

                    if (!this.ne.options.onSave) {

                        this.margin.setStyle({display: "none"})

                    }

                }, mouseClick: function() {

                    var B = this.ne.options.onSave;

                    var A = this.ne.selectedInstance;

                    B(A.getContent(), A.elm.id, A)

                }});

            nicEditors.registerPlugin(nicPlugin, nicSaveOptions);





            var nicCodeOptions = {

                buttons: {

                    'xhtml': {name: 'Edit HTML', type: 'nicCodeButton'}

                }



            };



            var nicCodeButton = nicEditorAdvancedButton.extend({width: "350px", addPane: function() {

                    this.addForm({"": {type: "title", txt: "Edit HTML"}, code: {type: "content", value: this.ne.selectedInstance.getContent(), style: {width: "340px", height: "200px"}}})

                }, submit: function(B) {

                    var A = this.inputs.code.value;

                    this.ne.selectedInstance.setContent(A);

                    this.removePane()

                }});

            nicEditors.registerPlugin(nicPlugin, nicCodeOptions);





            function salvaNote() {

                testo = document.getElementById("noteDiv").innerHTML;

                testo = encodeURI(testo);

                document.getElementById("saveNoteI").value = testo;

                document.getElementById("saveNoteForm").submit();

            }



            bkLib.onDomLoaded(function() {

                var myNicEditor = new nicEditor({fullPanel : true});

                myNicEditor.setPanel('boxEditor');

                myNicEditor.addInstance('noteDiv');

            });

			$(document).ready(function(e) {

				$("#noteDiv").scrollTop(100000000000000)

            });

			

        </script>

    </head>

    <body>

<?php if (!$loged) { ?>

            <form action="#" method="post">

                <p>

                    Nome Utente: <input type="text" name="name" /><br />

                    Password: <input type="password" name="password" /><br />

                    <input type="submit" value="Login" />

                </p>

            </form>

    <?php

} else {

    $elementiBackup = @dirList(".bkp");

	@rsort($elementiBackup,SORT_REGULAR);

    ?>

            <span style="font-size:24px;color:#009;font-weight:bold"><?php echo @$message; ?></span>



            <form id="AutoB" action="#" method="post">



                <input type="hidden" name="doBackup" value="1" />

                <table width="200" border="0">

                    <tr>

                        <td><input type="text" name="evDes" placeholder="Descrivi AutoBackup" /></td>

                        <td> <input type="image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5z2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMTQgNzkuMTUxNDgxLCAyMDEzLzAzLzEzLTEyOjA5OjE1ICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMjJUMTc6MDA6MzYrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTIyVDE3OjAwOjM2KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjAzYjE4Njk1LTMyMzYtZGQ0OS04M2U5LTE5YjdhNTg4MzBhODwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDozZGQ0ZjdhMy04MDQxLTQxNDQtYjE4Ni1hNTA5YTI3NDIwMTU8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDozZGQ0ZjdhMy04MDQxLTQxNDQtYjE4Ni1hNTA5YTI3NDIwMTU8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6M2RkNGY3YTMtODA0MS00MTQ0LWIxODYtYTUwOWEyNzQyMDE1PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowM2IxODY5NS0zMjM2LWRkNDktODNlOS0xOWI3YTU4ODMwYTg8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMjJUMTc6MDA6MzYrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4lis6xAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAvPSURBVHjazJhdbBzndYaf75v/mZ39IZe7XFKiJNoW3UoKHRhGYYU2hFyUVtKggGHUKdyihZuLAm194SsbqG+KGAhUGPCFYyeOfxDXBeoggNtEcezYDSqhleRYkiW7liVKomSTlEhx+bvc3fn/erErUiwV9C7oAIPFzJ6Zeec957zn/UYopfj/tOkAQoj1E4cO/SOPP/7XtSBoxcePH/u9l1/+/lHDMJmcnEybzabWaq7x07cPc+DB/czMLRJHEWmakaQpP379FT7770/Zu+8r/MXjf8Wbb/yYV3/4fXp6y5imiRAE3/72n42NjIxcNQxLnTlzevH48aMUCkUA3njjn5AAd921mzvvvIvBwW3ceefuZ956618mX3rph1f27//a+76fByBJEu0mm5qUAFiWhWFZ2I6Nn8tx+Gf/ys/+7W1+/e/vk/cLNFaW+cPxcR555BEMw2BhYcEOw+Dk4cO/vHr+/IXJNOWPlpaaNBoBjUawwdBjjz2OUor5+RvYtndw//79drPZ5NKlSxiGQZqm6ywqBVLrsGmZFlJKsjQlU4qBgUE+/fQTqpUqSAlCUigUKJZKqEwhpYZl2Tz00Ddypqnx7ru//Prs7PXD7XaTm5WjA7z77mEAwjDkm9/8hnnPPb/P6dOf8sEH79PX18fU1NR6ShUKKTvgDF1DSkGaKdIsBdG9qxAYuk5vb5lXf/QSfX19SCHwPI+jR49yzz33UiqVUEr5MzMzzM3NcbNqdIA0hSiKMQxTep7bF0UwPT2DUmAYxqYaQ4HsHmuGQGQaMgMjk7TWmgAE7RambiKEwtB1TMMkUwrHcZibm2NqehrXtSmXK33Dw1+hp6e0/gwdYGzsDwjDEMMwypZlVaIoIo4jDMNAKYWmaYRhSBAEtNttekqlDkMC0Lo7kt0jI0xeucLw8J34rsTL+WQqQ9M1sjjFMAwMwyYKQ4TQ8Dy31m4vsLzc3txlH3zwAXEcMzx8R6VYLNmzs7Ps3buPO+7YyfPPn8IwDMrlMmtrTQzd4MMTH+K6LmEYkmaKJM0Io4TH/vwv+dYfPwwIjh77DZOXLuG6bjeLCk3TMQyDMAxQSmEYZiVJmiwvr6Fp2gagarXM8vISlUq5omkaQdCmUCiyuFin3W5jWRb79+8nTRIU8PPDv+C9X/2KKApJk4Q4ToiTGMdxkZqkubZGvV5HSklPT2+HZSkRAgzDJAhCoijGNI3evXtHS1mWLlmWvQFoYGAI3y+xffvOfk3TUEoRhgGNxhpSSkAxMTGByjJURwKIohjIUArSNCNNE7IsJUsVaZqSqQwhBO12mzhO6CmV0DSJaRokSQxALuf78/P1ar1eX9rE0NGjR2m11hga2lnL5/Osrq502lsKTNPgwoULjI8/xMMPP0wcx+v5dhyHQqGwfiyEQAjB6uoqYRgCYNs2R478B9/73iG2b9+OaZrEcYJSGaZpoet6tdlcO5/L+RuA7r33PmZmrjEwMFgNw7D7xhv7ysoq999/P6Ojo1ukfqFep9TTgxQCBWRZysDAwKaYLMv47nefJY5DTNMgjmPiOEbXJdXqQKVeX8R1PTqtARw//iGXL19C17WBWq2PSqVCFEWAIEkShBAsLi5uAfPOO++wc9cuNE3D9Tw8z8N1PV588cVNcTdu3EBKSZqmGIZJksS4rkNPT5nV1eWBixfP8dlnH28AAgewqVZr/W+++c+88sqP6O3tJQzbKJWRZdltB+H4+Djnzp1jfHycdrtNu90miiKuXbu2maHuPdI0I5fziaKI1157nbNnz3LXXbv7i8UitdrABiDLamLbEYODtcr8/CJxHLO4WCcIAoSQvxWQpmkMDg7SbDY3nTdNc9OxoCN6aZph2zZpmtJqtVAKPM/rX1lZXZ8GOsCVK19gGKYdBEH1iSf+jrNnz3Lu3OeUSiWiKEKp2wNSSrFnzx7Onz+P4zjs2bOHkydPkqbpljgQpGmCZVns2LGLBx54gEKhxOXLF2q3vrC82QlDQzv6fD9fnpqa5tixY3iey40bc50WzhS3802HDh3i/PnzALz++ut89NFH5PN5Tpw4cRvwGYhOgSdJwpkzZ4jjmFKpVL01TgIEQYBtO5Xe3rKcmJhgdXUV23aYmpritxm4OI559tlnAXjuued49NFHAXj66acZGhrafF13FEopWVis02q1mJ6eotFYxXVzFV3XjU2jA6BYzNd8P8fs7CzNZpM4jmk0VonjeJP9uLkdO3aMRqPBwYMHefLJJ9fPP/XUUwRBsClWCkmSJCRxTGutSWcahMzPz+N5Xp/n+ZWVlaWZW7oMyuW+Kghs2yLLMoKgRRAEOI6D67pbCvu9994D4IUXXtjCnm3bm14gSRJ836e3t0wYRbTbra6DFJimaeTzhcoWhkqlUn+SxAwMDDI/P8/S0jKtVou77x4hCIItqXvwwQcJgoDh4eH/0ycrpdi1axf79u1lYmKSIAgYHNyGZVkAuK5T3QLI9wuDWdZ56OjoPUxNTVGv15mYOMfly5dZW2uwsrLcZUowNjbG2NgYi4uL65N6c1dtSEOr1eTs2bNcv36NanUA07To6+sjDENc18P3/dptGOqpJklMFEVIKbn77t3s2DHEyZMf4Tg5fvCDl3n11deIuqZe1zV03aDZbJJl6YbiCBBCIqVE1zVs2yFJUmzbYXm5wZ49ZTzPXU+lEJDL3RZQqT9NU5TKaDbbtNstnnjibzhw4AAffniKJOkMxI55i0mSuFOoSUKaZl1WFEIIpOxY286vJIpC8vki+/btQwhBvT7f1TeFUuC6zhZAmu/7/XGcrM+b1dVVLly4ysGD4xw4cICPP/6UqakZNE1i2xaapnU1JV0Hk2UZWZaSphlxnNBut0jTlFqtxsjI3Sws1Dl16jS6bnRjO/Ge978Ysiy7N5fLl03TxHFclpdXyOU8lpaW+clP3mZ0dB8jI7vZtq3G3NwNZmauU6/XabcD0jRbF744jlFK4XkuhUKBSqVCLufj+z6ff36OixcvYlmdlUqSJDiO0xnMbm5zUReLxb583s+fOHGMOE4YGhoiCNrYtkWS6Bw//hGu6zIycge1Wj/bt28DVLf7IAwDQKDrOlIKHMdldnaea9euMzc3y+nTnZTncrlbxoriwoXzVKs1isVCpSufSgfo66sOO47DK6+8xrZtg3znO4/TarVJkpQsyzBNkyBoc+TIf6GUolgsUi73kM/n8DyPDZcZsrraYH6+zvT0DI1GAyElptEZtktLS6RphpSSOA45ceI39Pf3c9999263bWcQmNZvrkBrtX6ef/45kiTBMAx6e3uJohilOgXbSY0iyxRJEhMEAfX6EjduLKyLZsfuCvycz1e/OgoIVKaI4qhbW51663SlYHR0FF3X+Oyzz2Nd1+V6ys6cOXX8mWf+/urY2Nd3mqbJ9eszfPnlFUqlXgzDRNd1NE1H1ztdY1n2+npt7sZsd1nTqSMhJFJIhOy0fhLHVKo1HMdBCIlSGWmaEoYhlmXi+3neeecXR9bWGl/eslBM60eO/Od0ltk7C4UCV65c4pNPTjE8PIJhGIDAMHQ0zcAwDHRdRwiB57lcvjxBHMdkWUartYauG0hNokkNISVh0GZ4eDfFYo44LhPHBsXCEotLq/i+Ty7nMzk5Ob1Fh3p6iqvlci+e57Jjxw6uXr2AUhG+X8T381iWjZQamibRNA0pNRzHYa2xTBiFKJXRDjx0Te/+32EoDANq/VXiZIj7v/Yelf4v+Olbf0q16pDLeTfXbEtbAEVR2HIcF8tysCybgYFtJElMs9noDkqB4zhI2VFogUApsB0Xw7TIshRdN9B0HdlVaiEEhmEiNR1bj5m9nmNxuQ/bTrEti1Kpl8XFBYKgvbLuVJRSCCGkYZh/MjS06291XXfa7SDWdU0JIciyjLhblB2GNCGl7KqsWmdDqa7tEZ0vJDenvRCCNE3R9YRms0gcW/T01MkyQ+RyvrW0tDh75crFfwCOKaU2AAEVYBjIA8nv4GOZ6NqfeeALYOFWQHQ/GZi3eqTf0ZYCEZAppfifAQDy1rjkEqrWmwAAAABJRU5ErkJggg==" value="Effettua Backup" /></td>

                        <td onclick='document.getElementById("AutoB").submit();' style="cursor:pointer;">EFFETTUA BACKUP</td>

                    </tr>

                </table>

            </form>



            <form style="margin-top:50px;" enctype="multipart/form-data" id="uploadFileForm" action="#" method="post">

                Descrizione: <input type="text" name="desc" />

                <input type="file" name="userFile">

                    <input type="submit" value="Carica il File" />

            </form>



            <form style="margin-top:50px;" id="restoreFileForm" onsubmit="if (confirm('Si  sicuri di procedere?\nCos facendo tutti presenti verranno cancellati per essere sostituiti\ncon quelli del backup'))

                            return true;

                        else

                            return false;" action="#" method="post">

                Seleziona Backup:<select name="restoreBackup">

    <?php

    for ($i = 0; $i < count($elementiBackup); $i++) {

        echo "<option value='" . ($i + 1) . "'>" . urldecode(substr($elementiBackup[$i], 0, -4)) . "</option>\n";

    }

    ?>

                </select>

                <div id="boxEditor" style="width:800px;"></div>

                <div id="noteDiv" contenteditable="true" onclick="document.getElementById('buttonSaveNote').style.display = 'block'" style="width:800px;height:300px; overflow:scroll;">

    <?php echo @file_get_contents(".bkp/note/note.txt"); ?>

                </div>

                <input type="button" id="buttonSaveNote" style="display:none;" onclick="salvaNote();" value="salva note" />

                <table class="buttons" width="400" border="0">

                    <tr>

                        <td><input style="position:relative;left:30px;" type="image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5z2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMTQgNzkuMTUxNDgxLCAyMDEzLzAzLzEzLTEyOjA5OjE1ICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMjJUMTY6Mzc6MzYrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTIyVDE2OjM3OjM2KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjJlZDNhNzgwLTBkYzEtZmM0Yi04ODlkLTdhNTMyNGRmOThmZDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpiMTZmYzhhNS05ZjA1LTZiNDctODIxOS1lZTAyYTA4ZjVkNjQ8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDpiMTZmYzhhNS05ZjA1LTZiNDctODIxOS1lZTAyYTA4ZjVkNjQ8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6YjE2ZmM4YTUtOWYwNS02YjQ3LTgyMTktZWUwMmEwOGY1ZDY0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoyZWQzYTc4MC0wZGMxLWZjNGItODg5ZC03YTUzMjRkZjk4ZmQ8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMjJUMTY6Mzc6MzYrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz7Hup2CAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAh7SURBVHjazJh7bFv1Fcc/1/de24nzshOaJn0kTdrRpA+VwqjWNtCORzc2VGBsDCFQy4AVDWlDCNDQYGhDE0gDxoQ20NgQCJhGh6rRTh0CCk1TujQ0fZKH82hedezETvx+Xd/72x/3OnFYhGDK2H7S0bWvfc/v8zvne87vZ0ss0JAk2LyIHYvs1CRTGOkEQ70pev0Q+EJ+FgqoWKL0lTsq3q5f27QkEUmJRPDC+XM9k13HztJ2KMS7UYjxZY4a2CwO3iRmx6QQmY+E+OQZ4Xv+ysmnW/hdPTR9aUAXwZXR1683WbJRIbSkmDPS74nka9eJR9bw5JcFtDXyyg4hRFaIyKAQ4T4hwl4hpnqFiAzNgvlfFB/sUjuroX4+P7YFpRI6EAMtAVrSND0F2TBMdEKoC6rvYdvL713S/ujiU0vnSeECAxlABnKpAqiEaXoKMlMw1gqZZup+8Vb5hw+5P1LB818DsskCEFBUCsWV5s1sbBYqlwIjDb7jkKil8dFnK/78bQ4W+pAXCsZlZ/l964J3Ov3vQN+HkBqG8iooWgLpKcilwciBkQVDh5gP3BtpXhte0rHvjL8vyYkF7UM1pWw9fCtHPEAyC0UOcK/wILfcBg03QSxopi0/pTBALYEahZ4nfhBpejJYDWRkgKe+Vfz7n+90Pbgol16qpLBNpZjIgvZFgCqdrHpkO3eUVUFGhWkdpsdS2HuO4yifgppNkIqAngFDMy0bBWURVYtizvYD54b7E3TKQPELt7v3bXjs8fqrt234+q5tFbtuv0S+Z3NNsmW5qtXZUsihNBMa5D4LKGdgryrmhnCSooyGvMIDlVUwGgZ1wIuzVoWKZkgHZ1MnNMhmoVJF6211/a2bVyXA3XYv3i0PPFGFsg5IgJwALQDhERgZZLR3aPL4udFjR7sybW39tJ6M8HEO9Hm4LgZWuFSqNy1l610bueXmdZQGfeBZacfxjcchK5t6AhACJBkWFdH72jPx5sd8tRLgbt1Ff8u9t3lwbIJU0PyS4gRHMdhlC3ASpkdgbITBvtHR9u7x9qNdudb2QY6cCXMqO3/gNu75Ks8+tZ0rFBsUX7MTPFvMOYQFJABPJdn2v1B318mvKUAmlSJN1Aduq38AZCOQLFiF4gTneli7gYYN8WUN+uSyWyO+m/H5GPD6hjq6JtoPndU/bO/nyJkYn1hAnS90cJ3Qef+F69lEbAw8cTDiJohhiTtXgt1uo0ilUgGSfUGGrk0GaikNW0CioNkJszByEcgCMQFyPoJroGkNjesS9Y03hOq/H/HfwngY7+j4wM9eGv/p3tPsBRIvdrLrO810XNOSKUGPgpEw/RoC1HKIdWOEujFUhA2gO0gfiSBkgpCzums2Dloc9IS1ooTpyEiAHoXsBMSHIDQEE1MQsUPRBrh8O1/ZWd541XJ2F6Su5+VTvEGZAiJm+YqDLIEWgtEDkEsiKQgFoHeabsIRqJqEnGqWJIBNFPRyK1I2zJUV3hcCDBdIU3DiIzgXpGMYX6GYLmugipJyCIdApEF2QW4SfG1gxLGVgASSAjAYwZubzqBkQ6BXmA1sTg8XsxuNEAW3LFHai8Hlg+6PCR1KU1kNbjcl+aebith8/w8vugndCVoYbA5ID0HoDGgaVABxELoFNBShfziIaEwHJBQXiAzoublaksRsZUgFQKoT7Oehswv/YXB5IC3D+/28D1Cv0vDOM+p+afUKGE+ZKUsGIO4z/RQDKiQikNZIKphiH+yfxtcY7V8CUdOr6rQioJuVUFimeShZBds4etsYvsNgVMLpAP7vPc2jUXjp7svY/dSPXb91t9SV4EtBZtjUqaaDCiiWaTA8hjGlcUGx1p/on2Jgh81YQsIPOb+5YztcYHeYZT8TlkKTQUsiFttxXa2Tixic6uDC7utsjT/6ptq1qsXRRGkxjAbMo0deew6r5HNACTAEHecZyOoM5oHwTtCPjSsosr6sxczDliGB3Q5CAcUCkyTzagiwKSiryvCsyZKL5Xh4h3EpHi7FkCCSBl/E9Kcy23vyMG5gAhiBDyY4AuRmgYJ4yVr0uhVK2ao0kTHNyAt7rrxIARkJRbV0FWR2Y1Gtax5EWDAu6/0ZGAnCAS9vYE0LQH+IHhEFqXY2G8gFeVYK7uXNVnC1ibnHPnmeDOcjU2EGWHsbVA3+MEB7KGoWwUw3GYnSNxxCzIitcDLVCm9ZAZjCrDDVAvv0+7zln1lsvs7tB9kPXh1+c5iH/+0Im9U5PxBkbCYaNkvHLqAIOAGcByqBKsA+TwTnA8t/5gFqTb1kXzObvFQPd+/j2XiKw3kOpVAJ3gADV9lYNhPucmvSY+A/A04XVIwBa4EGq0I0Zo9yltZnFiMXaGgS+CeEj4GuQuVauOuv/KPVywOFLbgQiN4J+tDZhmJFJgt6K/h9UL4a0gkYOg0eL5Qtt04/Ky3wfDSkguZuAGGgH5LHIDQAlfXgrIJ73uLgH4/y3U+Vx1ygvgBeNGCpGdrMUYiloHQlvP4JFy52s3jbBuTQBAx5wTUAxXXgaAClxtKYVd5G3DzjpYchNgpOGZZthN5puPdPPP9BNw+YS5475gLF8DIKRCDeCYYNKlfD/X/nnecOscfhZN2D23jotvVsXb3e3PKmo5A4C7Y+kB3m7igJsOXArkO5AuV1cCEKvzpKxxPv8utUijc/178f9hKae+7kbG0Sm+0iSJbD7r28su8Ee4B0/hdPaQnX37iWG69dyZbLl7KkrszsnTPakczy9sfhZICpg70cf/MU+wJT7AWmP//fMRKOtvsY37Ie9+gFuPFVfnlikMc+4/k1ZSVc2lRNc00ZSz1FlCIhTSeJBeKM9wTwTkU5CZyeLz2fa+zZyuv7f8LkYg/3/QePywv54zM/qoF1/I+GJITg/2n8awDmmgI71KKbqgAAAABJRU5ErkJggg==" value="Ripristina da backup" /></td>

                        <td><img style="position:relative;left:20px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5z2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMTQgNzkuMTUxNDgxLCAyMDEzLzAzLzEzLTEyOjA5OjE1ICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMjJUMTY6NTg6NDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTIyVDE2OjU4OjQ0KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmU1MTY0MDk4LWMwOGMtODI0Yi1iZjczLWM3NGQwMGJjYTViNzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo1YWY1ZTk3NS0xZDVkLTJiNDktYjVjZC0wNGRmNDkxMGVmZjk8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo1YWY1ZTk3NS0xZDVkLTJiNDktYjVjZC0wNGRmNDkxMGVmZjk8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NWFmNWU5NzUtMWQ1ZC0yYjQ5LWI1Y2QtMDRkZjQ5MTBlZmY5PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDplNTE2NDA5OC1jMDhjLTgyNGItYmY3My1jNzRkMDBiY2E1Yjc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMjJUMTY6NTg6NDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz6g0ZBSAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAg4SURBVHjazJjbj11VHcc/a62997nNOXPOnJlpgWJRKnIxCggEisVEwsVIjBiJIjxp5ImQmOiLMfHBv0B50TcDtAETYhMIIUgKlFarQoKkqCjl0mlnhpkylzNn39fFh73PzHTOTNupPrhPflnr7Ky912d/f7+1fr+9hXOO/6fD23jiO499ftOBDgfO3Qvie0oqlPJK81FS4XBYozFGo23RWmsciJ8KIU5vBfDMr46fG2glXBq6SApJkkWXJnF80POCSr3apNFo0qhVqAUj1KoNjDUkcUikeyRJQhivEEchUomrRkZa+5RS2jm7fYUu37lnaNBKtMTd1z/486uvvKHSj5ZRQiGVQkmFLM05i9YZuc7RJiPXGQBRvHLrG28fvq8XfnKw4te2D/STRx4fGpRlGTsndwVjo00sIQZb/gzWaYzTOGdwhePKvsbzHPNzK9TlpTVtYpTnbx9osxD3/QrzC9MrS/kKSI1zUCwGh3MFmHMG60pAm2NcjqpkfHwqptfLV4JAonW6faCl5fmhQdZYgkqQNUcM1qY4K0olXKGGM1hnsU6XiuVYm+O8nCxL6PV6ufJBSLF9oDjpDw0yxmJdLappsCrBGkogi3X2LHUKy9E2w7eGJI0IozDxAndxQIubKGSMoV4dXRyZqONkhDGijJOBMgWQG8A4jbU5WE2/H9Lv98OgdpFAV+y6engPshZjmIvSkygZYo0oQNbFjnMGU4IM3CadIYxCpmenekHdIsRFADVHOkODBBCGcT/MQrwgxBq5CrHWFqvNOo21BZBOYnJtsm/c89Bye7yKu5id+vi7x3DOYZ1FsPZEkoob3WXJbeGyAciqMuugnM2xaKSNSVKbL6RnMiODDQ+pEKjzA3nKx/MCcp2SZglSSHBgrM3TLERUQowWhbuswbIGY+3ZgV0RliiOzaEXn7LV1po+0nkYUjQhD377B+cGeval39Aa6bDvpvtQ0iOMe8WTWC/2dIKyIdqIdfGzEcRgrcaSIzTkeZa1Wm1dHy3UFtbDyZxErmA3SSVDQDNzH/L+yXeI4j533f4ASnlE8Qroat+LE4KRAsisix3rDM5qLIPA1iAdnoUs1anOdapzAdYDGaHVPGBQojqcN4eCutFmsnsZH0z9nRcPH0CbnEpQJYqjxSRJyW1EpkMyExbtwAbndYi2KdZmaKPJMh1rk2udOwwxujKPkAbB5mlEbhXtndEJTs2e4OWjvyPNUrrtHcvapEmq+2Q2RpuE3MZom2BcQm4LWw12LCY3JJHuWyOwZLjqAkJacN4WSWoTl62uAiFot8aZmfuIF159gluvu//M+B6RZias5poiX5V7jnU51hlAIIVCCIUvFBifPHGnhcqRjT5CucJtW2bNrYH2WmtvEUIw1t5BP1rmzXde8/bu3KOCsZA4z9bBaIzVJYxECIUUCqSHzjRWiCuqHf2Y8qS0RjCoiYQQU865Zy8gl4WXh9HKUecg8KvUaw1a9TGqokkUpqgSpMj0hUnhrcEgkcJDSYXOQUn/ulol+GWcLhDHIVmeYKyhXqujPHUncOicQJ/7zPX7d0xeQthLsVri+z6eCqirSSqtk8R5iHVqNX+dpQxqtS+cQinD2HjbteU1wq9qkizGaEO95TO/9BE6Vb84L1AgOr9uj3b23XinI0lSon6Kcwm5PsFS/m906lZTxqC8HbhJimL3lVLhbFFRXnUbYqyqqVWrOFej1akQ9y0v7P9ket9N33z0QuqhAy+98P7M7tnk0LVfzUjIiKIcJ1IwAc55WJevg5FIZJEKBkCDFh9VS1h0b7IQSZodn8VFyeED6czy1MjNlS970xdQMeYs9WdeOfNicEcaNg5/8V6Fq3nEK36ZJvKtlVltvVWl0ArlaoyM+ehY8fqT0czSqeCW7qW16c0qyKF9KM1SFnuzyEr/9X8d03tffzrLHYZKU2PMBjcNVClNCoUSXtGXXgHmPJpdn6QnePWJ5MT0e8mNjTF3ym2x7IeApJQEfhW/4tEck396743s5lefSnrGGWqjINw6ZeQgkBVKKMQARngFLJLWuEe0JPjj0+74/JT+UqNjZ0GAK+Y6L9BIq0qlppBCIBU0J9zfPngru+Hwk3ZWomi0ixW0GjNyAOed1Qrh0er69OYkh34bvbU8xy3tSW/ZWsdIq06n26Lb7Zwf6OSJMyzNp3i+ot2tU2v4tCbl+1PH3U1HnmLaWY9G21utZ9RZwTxQRjE67rE8K3ntyezYmZnk5tY4cbvTZGy8xcfTC7z83F/40aM/G84QG9/tB2VmZ6LOp67sMnF5leoIKClZOM3EziuDo195KPhspS6JlxWe9EqVvFX3tcZ9Fk4JXtufvGIy+dXuZT7CeEx9OM87b5/gxD/XFtfQ/FsBrf6XgolL6uza02T3VV1MXBsdneTY3ge8q6sNj3i5eM+X5apqdX0+OSn48+/dH4RTdxtiTrx7mvf+cZrZ0wvD9fp2gdYf3Z11rrlhBxPdycbua0ePfOEec70XOJKeh1KKZtcjmq9x7FlzcGZq8f65+VmOv/khK71oy3v+V0CDY/KyJmOdLrfd/ekj93y/fbuVMb4fkC02Ofj43P6/Hnn34ZmZadJEn/deQ5+DBglyYOc4BKCAAKgCBH6d7z5yx5HnTz7sDrzxkLvr63ufYa1wr5fjgnIDFlsBrbdzKdQBdgON8qZBCSRLE8A0wA9//LXnZ6d6C889c/RbwI7yWlsWPbY0A+RACsTAKWBuOy5rAjvXPaW/AUiW52ZB7QCbg1sBuuXkdoMZQAMZkABzwNL/JIY2yYeDYPHL/gV/J9w4/38GAOr8MdjS6NTHAAAAAElFTkSuQmCC" onclick="$('#dwnloadFileForm select').val($('#restoreFileForm select').val());

                                    $('#dwnloadFileForm').submit();" value="Download backup selezionato" /></td>

                        <td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5z2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMTQgNzkuMTUxNDgxLCAyMDEzLzAzLzEzLTEyOjA5OjE1ICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMjJUMTY6NTA6MTUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTIyVDE2OjUwOjE1KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI4NWI0ODcxLWNhZWMtNDA0NS04OTE4LTUxMmZhOTZjZDRlZDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo4ZWM5NzIxMC01NTdmLTczNGMtOTRiMy0wN2YwNjljNTM2ZmU8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo4ZWM5NzIxMC01NTdmLTczNGMtOTRiMy0wN2YwNjljNTM2ZmU8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6OGVjOTcyMTAtNTU3Zi03MzRjLTk0YjMtMDdmMDY5YzUzNmZlPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDEyLTAzLTIwVDIyOjQ3OjUwKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpiODViNDg3MS1jYWVjLTQwNDUtODkxOC01MTJmYTk2Y2Q0ZWQ8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMjJUMTY6NTA6MTUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz69dg1lAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAkbSURBVHjazJh5jFXVHcc/59777tvfvHmzMMwwjMCwyGYQFIRErQoqjcWUqqg1WrWaihHFRBtja7SbGy6lorValRQ0VhqtGNNo6wJqg4BLtUBHQNZhlrfPe/fd7Zz+8WZYdEAk2vSX3HeSd+9973N+53e+33MOSim+GGENxocgIPhGIwknJOEEDZoGu6+UwhjshiUh7YGrvhmQgMbE21uCz5w5JHWipev0Wm6po1Da8lmhtPbVjFrdA68NPCuUUghxSCrqxwnmtIZIbrLYuhveAfqOFUYLMH5pg/HJtY0tQm9sgHgEYoBfAOmxbssevr8xe/EexXNKqUOBhsIF94yNPz1n5PCIHgjQlSuwriuXX92ZW7G2IF/sPqgnR5caGn+dZOtVViBWCoQphUyax6RIDTXAA4ImBODBtzbbi7dXGpRSxf1AQZjxl8mp9+bOOAl8ARUHfB/sElgFNmdzPNzR/fZjGS4Eur4SRkcsbmDrTVlG5G3oAYa11dJ+aivS9pG+QlOgJUK8+uE25n6Ym6aU2qANvL+gLnD33MnHo8oO2e406d4shd69WKUMGBrjhg/l0Rntpz44LPApMOWIMAJ+WMeahQVGlGzoBZIxk5GntKB8he8pFKAFdPA91mcsG9gDMAAUPrkuNBNpkM8U8EoOml1CVx6e1OmreBSzJTBC3Di1vW7FqPCGBHzvcDxn17Hy52VmyXI1lSFDY+KcdjRDxy25oBRCAZEgHVv38uBOezmw72Ag9920tY1MhrCjsPvKCOUhlQa+QkkFCgp9FXxXcMnEEWLV+MRLw2HRF2FOSnH/3S4XB/qqMDow4fQRGBETO1cBBMpXGNEQxT37WPB+7/Ys3L5/EvS33vNpb9mTmzoIFosECg6OLdF0Dd+XSEk/lKLPsnEqPmeNbuWVqfUPnRxk6cCPjU1y4wNwc12+2l0JjJvRSqwpjpWxUID0JWY4CNkcl72zu7jRZT7QPdi0FwF47K6h2jU/NmtxbUFwdAIzbOBaLgiBEIAQKBRBXSccDdLT28u56/fdu1mwdkWcv07rhU6gBLQf30jLlKFYWasqfEAkZILwuXXtFu7tlhcALxwsjIPp0C0/qeeeG1yDWEUnNKGRcH0Ep+xUeyAGPkDTBIlIiI5inn98tJuZhepsLgAtw2sYOb2NSrGCkgolIBQwMII6T3/QwY+22bcBv/miUg8GBPCDc+pYdqtFQ1sZwuOaiLXW4FkuUsrq86LKpRDUxkO46RIfb9hN1vNpro8yetZxuBUX35MgIKBrhCJB/v6fzzn30+JyFy4fzDoOBwQwZVySR38mmD4jC+awFLVj6vBciet6aFr/O0IggHDMpFSokE+XqW9OoJs6nu0hNIEQgng0xKa9ezljQ+atfTAHcL4uEECqJspDd4S57OxeEDVRhk1qQtOgXDkAVc0UGEEdM2jg2B7SkwhNoIDaSIh0IcPs9fu2f+Awc2CKHwtQtVZC/OqGOLfNy4BuBJkwuYlYOECu7FShBAgODGO1FUgUtWYQ6VdY8OGO8qoCpwPvH+5/jhqoXyAuPT/FA2fmaEwondPHN9GaDNNTdvYDiAOjCEIQMTRQPjdu3tnzeFpdyld4oVJqvw59dUhWvNjLtH82kC5Ln+X/2sP6zjxhTQOpUL5E+grlq2orFZoEy/HoclWeozRm7euY96g4M2dZxEMCKsDyz3roLFaIaNoBGNl/eYpcxSWsB1k+tqX9unqxkcMszI4JqD7KOXeGeW5EDtOWVRU+MRokZQYoO1X3HriqWZIoCXnbJaqFWDpq2JRfNuv/BiYc0ZePpoZCYaY8nGDjtB7YIWEnkAwanDdmKAooez7aQcUs+h2/v9pRQJ1pEtR8nujaJxfvsucVJauPrYYCNPyihndmp6EkwQWaDY2z2hqq3lZxwVd4vsSUghqhYfYP4UAtIRU9tk3RFVzdOFR7fmT05dYA13z9IdMxbkqx7qIM4ZJXtYUEMLU5hanr5MsuSPClIqYMPOXzxo5etncWSZgGQimkJ1G+QvMVecchY0vOqWnkzyMTvz8xwj1HD1RdZL19XYHjSk7VLE1gRGOScChIX9lByKp7B6WgBsVThTRPeBaf9ubYtCNH1NAxhIbfny18KLkeXRWX6ZE6nm1L3vKdOE8eFdB361j10zKnKAvy/XWQqo0RiUewLBclFVJKNCVoQPBaJc2dXe6ylxwuey1F36a+Ahs/S2NICOkDUBJ8he357LVsxhi1PN1ae+XMKPcfsainx/ndI5KFtSVIUx2qWDRMvD6J73lVRe031mGayWaR4/zu0podFU6j+vVZZ6f44zyL1uOcAJNa6giHdfpcDxD71VwXghYzwFP5Lq7cZbcopfZ+KUPtERb/Nm4uHOIEyGoCHwgHTSLJOJ7jVmtCKnypqJc6aVFkYbb0+Y4KF/YveUDx+t/SzF4W4M2Poi7rd3WRz9rEdaM/s1Vp8HyJ4yqiQgNo/tKQJWH+462JJVMbh2M1JdHCJmbAIFoTR3oS35MoVYWp8XU03eaWvoL7bpGLBjHMLZ/kOW+Jyx/WJhUb8r2kMyVSykCT4PqSmNTRlcuaspMDtn4RqG3JqMgL3xkxmh5N4WsKI2AQjsWQCnzPh/7MRHydhOZzn5tnZZargHWHKcW+3jLXLCmw6JEQHU/ZOXY6eYYoQRsmdZpilZXhyZz/AJA9pIbmJvRnXzlt0gLXM9nb2U0lW8IvuGhUl6wDIhdQGs264E+BHNf2eHfgcddRiv0wYXD5KWGuWBAJtE8KBHnDKbM0K5/LulwOOAe7ffihUbHeRZMnRrp78lj5ElZXH37ZR+hV5VUCNAStGLwZznNRxnmmZHPFMeyuRwLzhc5w5bMeWElVbw89bOi2XItMMaJbHm7Zwa/4oKrbH9kvTA1SoyPWx/UFZ03J5upj3O5vA+5T/pHN1Xo2bb/4XudOasplavocIj5oQkMq0BQ0uTrFcIVFFavz8xKX9KvBNx8HnQ+1NQd4+fo64T7fZKhNqZDqSSRVVyyl8omU6hgSVfPryAOz+JZisBVjEDjDNJkzOcgZ80xt8ljNYJeSrLS9jzcUuRl4/X8JdHA0I5iNQTseu1GsHjgQ+NaB/p/ivwMA4OGmvtk/iPwAAAAASUVORK5CYII=" onclick="if (confirm('Si  sicuri di procedere all\'eliminazione?')) {

                                        $('#delFileForm select').val($('#restoreFileForm select').val());

                                        $('#delFileForm').submit();

                                    }" value="Elimina backup selezionato" /></td>

                    </tr>

                    <tr>

                        <td>RIPRISTINA</td>

                        <td>SCARICA</td>

                        <td>ELIMINA</td>

                    </tr>

                </table>



            </form>



            <form id="delFileForm" style="display:none;margin:0;padding:0;"  action="#" method="post">

                <select style="width:800px" name="delBackup" multiple="multiple" size="20">

    <?php

    for ($i = 0; $i < count($elementiBackup); $i++) {

        echo "<option value='" . ($i + 1) . "'>" . urldecode(substr($elementiBackup[$i], 0, -4)) . "</option>\n";

    }

    ?>

                </select>

                <br />

                <input type="submit" value="Download backup selezionato" />

            </form>



            <form id="dwnloadFileForm" style="display:none;margin:0;padding:0;"  action="#" method="post">

                <select style="width:800px" name="downloadBackup" multiple="multiple" size="20">

    <?php

    for ($i = 0; $i < count($elementiBackup); $i++) {

        echo "<option value='" . ($i + 1) . "'>" . urldecode(substr($elementiBackup[$i], 0, -4)) . "</option>\n";

    }

    ?>

                </select>

                <br />

                <input type="submit" value="Download backup selezionato" />

            </form>



            <form name="saveNoteForm" id="saveNoteForm" action="#" method="post">

                <input type="hidden" name="saveNoteI" id="saveNoteI" />

            </form>

            <br /><br />

            <!--<form action="#" method="post">

                <input type="hidden" name="patch" value="1" />

                <input type="text" name="nameFile" />

                <input type="submit" value="applica patch Database" />

            </form>-->





<?php } ?>

    </body>

</html>